---
title: "AnalyzeTWLoggerGPS"
author: "Katie Harrington"
date: "April 21, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Get Started
*This file takes ... and does ...

## Load libraries; set working directory and local time zone offset
*NOTE: Saunders is in UTM20S 
```{r echo=FALSE, warning=FALSE}
library(tidyverse)
library(dplyr)
library(maptools) # to calculate solarpos
library(stringr)
library(lubridate)
library(adehabitatLT)
library(geosphere)
library(ggpubr)
library(sp)
library(rgdal)
library(tibble)
library("rnaturalearth")
library("rnaturalearthdata")
library("sf")
library("ggspatial")
library(marmap)
library(mapdata)
library(metR)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(rstudioapi)
library(argosfilter)
library(tidyverse)
library(lubridate)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(devtools)
library(RColorBrewer)

# install.packages(c("adehabitatHR","rgdal","sp", "ggmap", "mapproj", "maptools", "rgeos","raster","leaflet","move","ctmm","BBMM","PBSmapping"))

# Next, we're going to load our packages
packagelist <- c("adehabitatHR","rgdal","sp", "ggmap", "mapproj","rgeos","maptools","raster","leaflet",
                 "move","ctmm","BBMM", "PBSmapping")  
lapply(packagelist, require, character.only = TRUE)


source('UTMConversionfxns.R')
# if(!requireNamespace("devtools")) 
# install.packages("devtools")
# devtools::install_github("dkahle/ggmap")


# Set the Working Directory
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path ))
rm(current_path)
getwd()

tzOffset <-"Etc/GMT+3"
```

## Combine Data and calculate summary stats
```{r warnings=FALSE}
# Select file to import
filename <- file.choose()
# Import IGU GPS data (ScriptOutputs from KML builder scripts)
pathChoice <- dirname(filename)
# This imports all CSV files in the directory chosen
filenames <- list.files(path = pathChoice, pattern = "*.csv", all.files = FALSE, full.names = TRUE, recursive = FALSE, ignore.case = TRUE)

# Load deployment times from CSV
depTimes <- read_csv(paste0(getwd(),"/depTimes.csv"))
depTimes$startTime <- as.POSIXct(strptime(depTimes$startTime,format="%m/%d/%Y %H:%M"),tz=tzOffset)
depTimes$endTime <- as.POSIXct(strptime(depTimes$endTime,format="%m/%d/%Y %H:%M"),tz=tzOffset)

# Create an empty dataframe to hold all the data
dataset = data.frame()
# Iteratively import CSV files from each deployment, find sunrise and sunset times, and create columns for sorting and processing.
for(i in 1:length(filenames)) {
  data <- read_csv(filenames[i],
                   col_types = cols(TimeUTC = col_character(),
                                    Lat = col_double(),
                                    Long = col_double()))
  # select only columns with name, lat, long, etc.
  data <- data[,c("Lat","Long","DateUTC","TimeUTC")]
   # extract deployment name from filename
  name <- strsplit(filenames[i],"[.]")[[1]][1] # This removes the .CSV
  name <- str_replace_all(name,"\\\\","/") # this makes it work for both windows and mac
  name <- sapply(strsplit(name,"[/]"),tail,1) # Take just the filename
  name <- sapply(strsplit(name,"[_]"),tail,1) # Take just the filename
  name <- sapply(strsplit(name,"[-]"),head,1) # Take just the filename
  data$name <- name
  # Create DateTime (UTC)
  data$dt  <- as.POSIXct(strptime(paste(data$DateUTC, data$TimeUTC,sep=" "),format = "%m/%d/%Y %H:%M:%S"), tz="GMT")
  attr(data$dt, "tzone") # Check tz
   # select only columns with name, lat, long, etc.
  data <- data[,c("name","dt", "Lat","Long")]
  colnames(data) <- c("name","dt","lat","long")
  # Convert to local time
  data$dttz <- data$dt # set dttz to dt
  attr(data$dttz, "tzone") <- tzOffset # change the timezone to tzOffset
  data <- data %>% arrange(dttz)
  startTime <- depTimes %>% filter(ID == name) %>% .$startTime
  endTime <- depTimes %>% filter(ID == name) %>% .$endTime
  data <- subset(data, data$dttz >= startTime & data$dttz <= endTime)

  # Create useful identifiers
  data$date <- as.Date(data$dttz, tz = tzOffset)
  data$yr <- year(data$dttz)
  data$mth <- month(data$dttz)
  data$hr <- hour(data$dttz)	
  data$yday <- yday(data$dttz)
  data$yday <- sprintf('%03d',data$yday)
  data$yday <- paste('D',data$yday,sep='')
  data$indday <- as.factor(paste(data$name, data$yday, sep ='_', collapse = NULL))

  # Calculate distance between consecutive points (km)
  source('Point2Point-stats.R')
  # Determine Solar Position for each point
  source('SunriseSunsetTimes.R')
  
  data <- data %>%
  arrange(dttz) %>%
  #Tidy up some unused columns
  mutate(period = cumsum(replace_na(lag(astronomical) != astronomical, 1)),  
         cycle = floor(period / 4))
  #convert dur (time between consecutive points) to minutes
  data$dur <- data$dur*60 
  # Combine into Dataset
  if(i==1) dataset <- data else dataset <- rbind(dataset,data)
}

# Check for NAs
sapply(dataset, function(x) sum(is.na(x)))
# cleanup
rm(v1, v2, v3,xy, i, name,data)
```

## Rediscretize data
*Saves rediscretized data (2min) as redist_Astro.RData
```{r}
# add unique identifier to group by name and period in plots
dataset$namePeriod <- paste(dataset$name, dataset$period, sep = "-")
#### Rediscretize Data ####
dataset_SP <- longlat_to_UTM(dataset$long,dataset$lat)
dataset_SP_All <-bind_cols(dataset_SP,dataset) # combine all data
dataset_SP_All <- SpatialPointsDataFrame(cbind(dataset_SP$x, dataset_SP$y), dataset_SP_All, match.ID = FALSE)
dataset_SP_All <- dataset_SP_All[!duplicated(dataset_SP_All$dt),] # remove duplicate times
# make sure there are no duplicate times (JAF)
dataset_SP_All$dt[duplicated(dataset_SP_All$dt)] 
# Inputs for AdeHabitatLT Resicretization Function
xy <- coordinates(dataset_SP_All)
id <- dataset_SP_All$name
da <- dataset_SP_All$dt
burstAll <- dataset_SP_All$namePeriod 

# Create a Trajectory (used in Rediscretization function)
# burst allows each period to be rediscretized individually
litr <- as.ltraj(xy, da, burst = burstAll, id,  typeII = TRUE)
#head(litr)
plot(litr)
## Rediscretize Trajectories
reLitr <- redisltraj(litr, 120, burst = burst, type = "time") # 120 seconds is 2 minutes
reLitr5min<- redisltraj(litr, 300, burst = burst, type = "time") # 300 seconds is 5 minutes
#head(reLitr)
plot(reLitr)
# Convert to Dataframe
rediscretized_data <- ld(reLitr)
rediscretized_data5min <- ld(reLitr5min)


dataset_sum <- dataset %>% 
  subset(.,select = c(astronomical, cycle, period, namePeriod)) %>% 
  distinct %>% 
  mutate(namePeriod = as.factor(namePeriod))
class(dataset_sum$namePeriod)
class(rediscretized_data$burst)

# Join dataset to rediscretized data
redist_Astro <- left_join(rediscretized_data, 
                         dplyr::select(dataset_sum, namePeriod, cycle, period, astronomical), by = c("burst"="namePeriod"))
redist_Astro <- redist_Astro %>% arrange(id,cycle,period)
redist_Astro$mth <- month(redist_Astro$date)
attr(redist_Astro$date, "tzone")
redist_Astro$dt <- redist_Astro$date
redist_Astro$dttz <- redist_Astro$dt
attr(redist_Astro$dttz, "tzone") <- tzOffset # change the timezone to tzOffset
redist_Astro$yday <- yday(redist_Astro$dttz)
redist_Astro$ID <- redist_Astro$id
redist_Astro$id <- NULL
# Determine Season (calculated from 2017 solstices and equinoxes)
redist_Astro$season <- rep('NA')
redist_Astro[which(redist_Astro$yday > 79 & redist_Astro$yday <= 171),]$season <- 'Fall'
redist_Astro[which(redist_Astro$yday > 171 & redist_Astro$yday <= 265),]$season <- 'Winter'
redist_Astro[which(redist_Astro$yday > 265 & redist_Astro$yday < 355),]$season <- 'Spring'
redist_Astro[which(redist_Astro$yday >= 355 | redist_Astro$yday <= 79),]$season <- 'Summer'
unique(redist_Astro$season)
redist_Astro <- redist_Astro %>% 
  group_by(season,ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup
distanceSummary <- redist_Astro %>% 
  group_by(season, ID,dayNight) %>% 
  summarize(periodDist = sum(dist,na.rm = TRUE),
            periodmeanDist = mean(dist,na.rm = TRUE),
            periodSDdist = sd(dist,na.rm = TRUE))
# save(redist_Astro,file="redist_Astro.RData")
```


## Add states to GPS
This creates and saves GPS_states.
```{r}
# Load R workspace
load("~/Projects/R/TWlogger/data_states.RData")
FullAccStatesGPS <- left_join(data_states, redist_Astro, by = c("ID","dttz"))

# Function for getting the mode of a vector
mode <- function(x) {
  unique_x <- unique(x)
  unique_x[which.max(tabulate(match(x, unique_x)))]
}

# columns of interest are ID, dttz, state_classif, x, y
FullAccStatesGPS2 <- FullAccStatesGPS %>% 
  group_by(ID) %>% 
  # This associates each acceleration value with the following GPS hit
  mutate(gps_hit = lag(cumsum(!is.na(x)), default = 0))

# Just the GPS data
GPS_data <- FullAccStatesGPS2 %>% 
  drop_na(date.y) %>% 
  dplyr::select(ID, gps_hit, dt, dttz, x, y)

GPS_states <- FullAccStatesGPS2 %>% 
  # For each bird's GPS hit...
  group_by(ID, gps_hit) %>% 
  # Find the state mode for the associated acceleration values
  summarize(state = mode(state_classif)) %>% 
  # Join GPS data 
  left_join(GPS_data, by = c("ID", "gps_hit")) %>% 
  drop_na(dttz) 
# rm(FullAccStatesGPS2)
# rm(GPS_data)
# GPS_data <- GPS_data %>% 
GPS_statesSP <-   SpatialPointsDataFrame(cbind(GPS_states$x, GPS_states$y), GPS_states, match.ID = FALSE)
crds <-   UTM_to_longlat(GPS_statesSP,20,'south')
colnames(crds) <- c('long','lat')
GPS_states$lat <- crds$lat
GPS_states$long <- crds$long
GPS_states$state <-as.factor(GPS_states$state)

# Recalculate astronomical
data <- GPS_states
# Create useful identifiers
data$date <- as.Date(data$dttz, tz = tzOffset)
data$yr <- year(data$dttz)
data$mth <- month(data$dttz)
data$hr <- hour(data$dttz)	
data$yday <- yday(data$dttz)
data$yday <- sprintf('%03d',data$yday)
data$yday <- paste('D',data$yday,sep='')
data$indday <- as.factor(paste(data$name, data$yday, sep ='_', collapse = NULL))
source('SunriseSunsetTimes.R')
GPS_states <- data
# Determine Season (calculated from 2017 solstices and equinoxes)
GPS_states$yday <- yday(GPS_states$dttz)
GPS_states$season <- rep('NA')
GPS_states[which(GPS_states$yday > 79 & GPS_states$yday <= 171),]$season <- 'Fall'
GPS_states[which(GPS_states$yday > 171 & GPS_states$yday <= 265),]$season <- 'Winter'
GPS_states[which(GPS_states$yday > 265 & GPS_states$yday < 355),]$season <- 'Spring'
GPS_states[which(GPS_states$yday >= 355 | GPS_states$yday <= 79),]$season <- 'Summer'
unique(GPS_states$season)

#Combine astronomical to day and night
GPS_states <- GPS_states %>% 
  group_by(season,ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"Day","Night")) %>%
  ungroup

save(GPS_states,file="GPS_states.RData")
```

## Recalculate distance between points

```{r}
data <- GPS_states
data$name <- GPS_states$ID
source('pt2pt_fxns.R')   
#Calculate distance, speed, and directions between successive points

#Order the dataframe in order to ensure the correct application of our coming functions
data$name <- as.character(data$name)
data <- data[order(data$name,data$dttz),]
library(fossil)

calcdist <- function(x) pt2pt.distance(longitude=x$long,latitude=x$lat)
calcdur <- function(x) pt2pt.duration(datetime=x$dttz)
calcdir <- function(x) pt2pt.direction(longitude=x$long,latitude=x$lat)

## Specify functions to calculate FORWARD and BACKWARD dist, dur and spd over lists of id's. 
## NOTE: this will allow you to calculate trajectorie speeds and directions for a large number of birds at once
v1 <- lapply(split(data,data$name),"calcdist")
v2 <- lapply(split(data,data$name),"calcdur")
v3 <- lapply(split(data,data$name),"calcdir")

## create dist vector in meters
data$dist <- as.numeric(unlist(v1))
## this converts the distance from KM to MI
# data$dist <- data$dist * 0.621371
##converts duration from S to Hrs 
data$dur <- as.numeric(unlist(v2))/3600
##Speed is in Miles/Hr
data$spd <- data$dist/data$dur
data$dir <- as.numeric(unlist(v3))
GPS_states <- data

save(GPS_states,file="GPS_states.RData")

```


# Plot nighttime cumulative distance traveled by season

```{r}
dist <-GPS_states %>% 
  group_by(season,ID,dayNight) %>%
  summarize(Dist=sum(dist/1000,na.rm = TRUE))

mdist <- dist %>%
  group_by(season,dayNight) %>% 
  summarize(mDist=mean(Dist)) %>% View
  mutate(prop=)
m

Pdist <-dist %>% 
  ggplot()+
  geom_boxplot(aes(dayNight,Dist,color=season)) + 
  labs(x= "Period",
       y = "Cumulative distance (km)",
       title = "Cumulative distance (km) per period by Season") + 
  theme_classic(base_size = 13) + 
  scale_color_discrete(name = "Season") +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
Pdist


ggsave(Pdist, file="Cumulative distance (km) per period by Season.png",dpi=300)

# Test for seasonal difference in nighttime cumulative distance traveled
nDist <- GPS_states %>% 
  group_by(season,dayNight,ID) %>% 
  filter(dayNight=="Night") %>%
  summarize(nDist=sum(dist/1000))
# Test for normality
shapiro.test(nDist$nDist[nDist$season=="Summer"])
shapiro.test(nDist$nDist[nDist$season=="Winter"])

# Test for equal variances
var.test(nDist ~ season,data=nDist) #Variance is unequal p=0.03201

# Test for seasonal differences
test <- t.test(nDist ~ season,data=nDist,var.equal = TRUE)
test

sd(odbaRated$odbaGrate[odbaRated$season=="Summer"])
sd(odbaRated$odbaGrate[odbaRated$season=="Winter"])

```


# Plot 24-hr ODBA by total distance traveled

```{r}
sumDistWI <- GPS_states %>%
  group_by(season,ID,dayNight) %>% 
  filter(season=="Winter",
         dayNight=="Day") %>%
  summarize(cumDistkm = sum(dist/1000,na.rm = TRUE),
            meanStepLengthm = mean(dist,na.rm = TRUE),
            maxStepLengthm = max(dist,na.rm = TRUE)) %>%
  left_join(.,sumODBA) 
mean(sumDistWI$maxStepLengthm)

m1 <- lm(sumDist ~ sumODBA, data=sumDist)
m2 <- lm(sumDist ~ sumODBA,data=sumDistSU)
m3 <- lm(sumDist ~ sumODBA,data=sumDistWI)
summary(m3)
coef(m3)
rsq(m1)
rsq(m2)
rsq(m3)


plot(sumDist ~ sumODBA, data=sumDistWI, main = "Dist (m) vs ODBA")
abline(m3)
summary(m3)


psumDistSU <-  ggplot() +
  geom_point(data=sumDistSU,aes(sumDist,sumODBA)) +
  # geom_abline(intercept=coef(m1)[1],slope=coef(m1)[2]) +
  geom_smooth(data=sumDistSU,aes(sumDist,sumODBA),method = "lm",color="black") +
  # stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  labs(x="Total daily distance (km)",
       y = "Total daily ODBA (g)",
       title = "Daily ODBA by total daily distance traveled") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +

psumDistSU

psumDistWI <-  ggplot() +
  geom_point(data=sumDistWI,aes(sumDist,sumODBA)) +
  # geom_abline(intercept=coef(m1)[1],slope=coef(m1)[2]) +
  geom_smooth(data=sumDistWI,aes(sumDist,sumODBA),method = "lm",color="black") +
  # stat_smooth_func(geom="text",method="lm",hjust=0,parse=TRUE) +
  labs(x="Total daily distance (km)",
       y = "Total daily ODBA (g)",
       title = "Daily ODBA by total daily distance traveled") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +

psumDistWI           

# Save a file at 300 ppi
ggsave(psumDist, file="Daily ODBA by total daily distance traveled.png",dpi=300)
```

#### Plot individuals to validate models

```{r}
PG53 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUd[xyStateSUd$ID=="G53",],aes(x=long,y=lat, color = ID),alpha=0.8,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer daytime distribution by individual") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PG53
```



#### Plot daytime ODBA by daytime total distance traveled

```{r}
sumDistN <- GPS_states %>%
  group_by(season,ID,dayNight) %>% 
  filter(dayNight=="Night") %>% 
  summarize(sumDistN = sum(dist/1000,na.rm = TRUE)) %>%
  left_join(.,sumODBA) 

# Test for normality
shapiro.test(sumDistN$sumDistN[sumDistN$season=="Summer"])
shapiro.test(sumDistN$sumDistN[sumDistN$season=="Winter"])

# Test for equal variances
var.test(sumDistN ~ season,data=sumDistN) #Variance is unequal p=0.03201

# Test for seasonal differences
test <- t.test(sumDistN ~ season,data=sumDistN,var.equal = TRUE)
test

sd(sumDistN$sumDistN[sumDistN$season=="Summer"])
sd(sumDistN$sumDistN[sumDistN$season=="Winter"])
```

#### Calculate nighttime total distance traveled to cross-validate exclusion

```{r}

```

#### Plot seasonal difference in daily distance traveled by solar hour


```{r}
# Create SolarMidnight based hourly bins
GPS_states$solarMidnight <- hms::as.hms((GPS_states$solarnoon- dhours(12)),tz = tzOffset)
GPS_states$time <- hms::as.hms(GPS_states$dttz,tz = tzOffset)
GPS_states$timeBin <- floor(as.numeric(difftime(GPS_states$time, GPS_states$solarMidnight,units = "hours")))
GPS_states$timeBin <- ifelse(GPS_states$timeBin < 0,GPS_states$timeBin+24,GPS_states$timeBin)
GPS_states$hr <- hour(GPS_states$dttz)
GPS_states$night <- NULL

GPS_states$dawnT <- hour(GPS_states$dawn) + second(GPS_states$dawn)/60
GPS_states$duskT <- hour(GPS_states$dusk) + second(GPS_states$dusk)/60

# Meanline summer
meanlineGPSSU <- GPS_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin) %>%
  summarize(distSum = sum(dist/1000,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanDist = mean(distSum))
# Meanline winter
meanlineGPSWI <- GPS_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(distSum = sum(dist/1000,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanDist = mean(distSum))

# Calculate time of mean dawn and dusk and create dataframes to use for shading bins in total daily ODBA plot
shadeGPSSU = data.frame(x1=c(0,mean(unique(GPS_states$duskT[GPS_states$season == "Summer"]))),
                     x2=c(mean(unique(GPS_states$dawnT[GPS_states$season == "Summer"])),23),
                     y1=c(0,0),
                     y2=c(15,15))
shadeGPSWI = data.frame(x1=c(0,mean(unique(GPS_states$duskT[GPS_states$season == "Winter"]))),
                     x2=c(mean(unique(GPS_states$dawnT[GPS_states$season == "Winter"])),23),
                     y1=c(0,0),
                     y2=c(15,15))

# Summer total ODBA per solar hour
PGPSSum24SU <- GPS_states %>%
  filter(season == "Summer") %>% 
  group_by(ID, timeBin) %>%
  summarize(distSum = sum(dist/1000,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=distSum, group=ID),alpha=0.7) +
  geom_line(data=meanlineGPSSU,aes(x=timeBin, y=meanDist),color="black",size=1.5) +
  ylim(0,15) +
  scale_x_continuous(breaks = seq(0,23, by = 1),expand = c(0, 0)) +
  labs(x="Solar Hour",
       y = NULL,
       title = "(b)") + 
  geom_rect(data=shadeGPSSU, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PGPSSum24SU

# Winter total ODBA per solar hour
PGPSSum24WI <- GPS_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(distSum = sum(dist/1000,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=distSum, group=ID),alpha=0.7)+
  geom_line(data=meanlineGPSWI,aes(x=timeBin, y=meanDist),color="black",size=1.5) +
  ylim(0,15) +
  scale_x_continuous(breaks = seq(0,23, by = 1),expand = c(0, 0)) +
  labs(x=NULL,
       y = NULL,
       title = "(a)") + 
  geom_rect(data=shadeGPSWI, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PGPSSum24WI

PGPS24Seas <- ggarrange(PGPSSum24WI,PGPSSum24SU,nrow=2)
PGPS24Seas <- annotate_figure(PGPS24Seas,
               top = text_grob("Seasonal cumulative distance by solar hour", color = "black", size = 14, just="right"),
               #bottom = text_grob("Figure 1. Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).", color = "black",hjust = 1, x = 1, size = 10)#,
               left = text_grob("Distance (km)", color = "black", rot = 90)
)

PGPS24Seas
rm(meanlineSU,meanlineWI,PodbaSum24SU,PodbaSum24WI)
# Save a file at 300 ppi
ggsave(PGPS24Seas, file="Seasonal cumulative distance per solar hour_shaded.png",dpi=300)
```


#### Filter GPS positions to plot by state and by ID
```{r echo=FALSE, warnings=FALSE}
# Filter summer by day and night
xyStateSU <- GPS_states %>%
  filter(season=="Summer")

xyStateWI <- GPS_states %>%
  filter(season=="Winter")

# Filter summer by day and night
xyStateSUd <- GPS_states %>%
  filter(season=="Summer",
         dayNight=="Day")
xyStateSUn <- GPS_states %>%
  filter(season=="Summer",
         dayNight=="Night")

# Filter winter by day and night
xyStateWId <- GPS_states %>%
  filter(season=="Winter",
         dayNight=="Day")
xyStateWIn <- GPS_states %>%
  filter(season=="Winter",
         dayNight=="Night")

# Filter summer by states
xyStateSU4 <- GPS_states %>%
  filter(season=="Summer",
         state=="4")
xyStateSU3 <- GPS_states %>%
  filter(season=="Summer",
         state=="3")
xyStateSU2 <- GPS_states %>%
  filter(season=="Summer",
         state=="2")
xyStateSU1 <- GPS_states %>%
  filter(season=="Summer",
         state=="1")

# Filter by winter
xyStateWI <- GPS_states %>%
  filter(season=="Winter")

# Filter winter by states
xyStateWI4 <- GPS_states %>%
  filter(season=="Winter",
         state=="4")
xyStateWI3 <- GPS_states %>%
  filter(season=="Winter",
         state=="3")
xyStateWI2 <- GPS_states %>%
  filter(season=="Winter",
         state=="2")
xyStateWI1 <- GPS_states %>%
  filter(season=="Winter",
         state=="1")

# Set zoom. Adjust this to fit all the data (20 is all the way zoomed in)
mapZoomSU <- 14 
mapZoomWI <- 12 

# Plot the extent of this map (NOTE: must adjust zoom parameter)
myMapSU <-  get_googlemap(center = c(lon = mean(c(min(xyStateSU$long), max(xyStateSU$long))),  
                                   lat = mean(c(min(xyStateSU$lat),max(xyStateSU$lat)))),
                        zoom = mapZoomSU, 
                        scale = 2,
                        extent="device",
                        maptype="hybrid", #"terrain"
                        style = c(feature = "all", element = "labels", visibility = "off"))
myMapWI <-  get_googlemap(center = c(lon = mean(c(min(xyStateWI$long), max(xyStateWI$long))),  
                                   lat = mean(c(min(xyStateWI$lat),max(xyStateWI$lat)))),
                        zoom = mapZoomWI, 
                        scale = 2,
                        extent="device",
                        maptype="hybrid", #"terrain"
                        style = c(feature = "all", element = "labels", visibility = "off"))

# State Colors (4 states)
colState4 <- c("4" = "#B2182B", "3" = "#F4A582", "2" = "#92C5DE", "1"= "#2166AC")
# State Colors (2 states)
colState2 <- c("4" = "#B2182B", "3" = "#B2182B", "2" = "#2166AC", "1"= "#2166AC")

shapeSU <- c("B50"=0, "C51"=1, "G53"=2, "M57"=3, "X56"=4, "Z55"=5, "Z59"=6)

```


#### Plot GPS positions by state
This needs love

```{r}
# THIS NEEDS LOVE: Do density of points? Smaller points? 
PxyStateSUd <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUd,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  annotate("text", x = -60.22, y = -51.2915, label = "a", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Summer daytime distribution of states") + 
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank())
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyStateSUd

PxyStateSUn <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUn,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  annotate("text", x = -60.22, y = -51.2915, label = "c", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Summer nighttime distribution of states") + 
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank())
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyStateSUn

PxyStateSU <- ggarrange(PxyStateSUd,PxyStateSUn,nrow=2)
# PxyStateSU
# ggsave(PxyStateSU, file="Summer distribution of states.png",width=12, height=8, dpi=300)

# Plot winter distribution of states
PxyStateWId <- ggmap(myMapWI) + 
  geom_point(data = xyStateWId,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  annotate("text", x = -60.05, y = -51.285, label = "b", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Winter daytime distribution of states") + 
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3) +
  annotate("rect", xmin = -60.255, xmax = -60.22, ymin = -51.32, ymax = -51.29,
  alpha = .5)
# PxyStateWId

PxyStateWIn <- ggmap(myMapWI) + 
  geom_point(data = xyStateWIn,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  annotate("text", x = -60.05, y = -51.285, label = "d", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Winter nighttime distribution of states") + 
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3) +
  annotate("rect", xmin = -60.255, xmax = -60.22, ymin = -51.32, ymax = -51.29,
  alpha = .5)
# PxyStateWIn


PxyStateWI <- ggarrange(PxyStateWId,PxyStateWIn,nrow=2)
# PxyStateWI

PxyStateSeas <- ggarrange(PxyStateSU,PxyStateWI,ncol=2)
PxyStateSeas
# PxyStateSeas <- annotate_figure(PxyStateSeas,top = text_grob("Seasonal distributions of state classifications", color = "black", size = 14, just="left"))

ggsave(PxyStateSeas, file="Seasonal distribution of states.png",width=12, height=8, dpi=300)
```


## Plot GPS positions by ID
```{r echo=FALSE, warnings=FALSE}
# Plot summer daytime distribution of individuals
PxyIDSUd <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUd,aes(x=long,y=lat, color = ID),alpha=0.8,size=0.8) +
  # scale_color_manual(values = colState4) +
  # scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  annotate("text", x = -60.22, y = -51.2915, label = "a", color="white")
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Summer daytime distribution by individual") + 
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyIDSUd

# Plot summer nighttime distribution of individuals
PxyIDSUn <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUn,aes(x=long,y=lat, color = ID),alpha=0.8,size=0.8) +
  # scale_color_manual(values = colState4) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  annotate("text", x = -60.22, y = -51.2915, label = "c", color="white")
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Summer nighttime distribution by individual") + 
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyIDSUn

PxyIDSU <- ggarrange(PxyIDSUd,PxyIDSUn,nrow=2)
# PxyIDSU
# ggsave(PxyIDSU, file="Summer distribution by ID.png",width=12, height=8, dpi=300)

# Plot winter daytime distribution of individuals
PxyIDWId <- ggmap(myMapWI) + 
  geom_point(data = xyStateWId,aes(x=long,y=lat, color = ID),alpha=0.8,size=0.8) +
  # scale_color_manual(values = colState4) +
  # scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  annotate("text", x = -60.05, y = -51.285, label = "b", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Winter daytime distribution by individual") + 
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
  annotate("rect", xmin = -60.255, xmax = -60.22, ymin = -51.32, ymax = -51.29,
  alpha = .5)
# PxyIDWId

PxyIDWIn <- ggmap(myMapWI) + 
  geom_point(data = xyStateWIn,aes(x=long,y=lat, color = ID),alpha=0.8,size=0.8) +
  # scale_color_manual(values = colState4) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank()) +
  annotate("text", x = -60.05, y = -51.285, label = "d", color="white") +
  # labs(x="Longitude",
  #      y = "Latitude",
  #      title = "Winter nighttime distribution by individual") + 
  # theme(legend.position="right", 
  #       plot.title = element_text(hjust = 0.5)) +
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
  annotate("rect", xmin = -60.255, xmax = -60.22, ymin = -51.32, ymax = -51.29,
  alpha = .5)
# PxyIDWIn


PxyIDWI <- ggarrange(PxyIDWId,PxyIDWIn,nrow=2)
# PxyIDWI

PxyIDSeas <- ggarrange(PxyIDSU,PxyIDWI,ncol=2)
ggsave(PxyIDSeas, file="Seasonal distribution by individual.png",width=12, height=8, dpi=300)

```


## Create Summer plots, one per state, colored by ID
```{r}
PxyStateSU4 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU4,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y="Latitude",
       title = "Summer distribution of state 4") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU4
PxyStateSU3 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU3,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 3") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU3
PxyStateSU2 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU2,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 2") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU2
PxyStateSU1 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU1,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 1") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU4

PxyStateSUperState <- ggarrange(PxyStateSU1,PxyStateSU2,PxyStateSU3,PxyStateSU4,nrow=2,ncol=2)
PxyStateSUperState
# This will save a file at 300 ppi
ggsave(PxyStateSUperState, file="Summer distribution of states.png",width=12, height=6, dpi=300)
```


## Create winter plots, one per state, colored by ID
```{r}
PxyStateWI4 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI4,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y="Latitude",
       title = "Winter distribution of state 4") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI4
PxyStateWI3 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI3,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 3") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI3
PxyStateWI2 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI2,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 2") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI2
PxyStateWI1 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI1,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 1") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI1

PxyStateWIperState <- ggarrange(PxyStateWI1,PxyStateWI2,PxyStateWI3,PxyStateWI4,nrow=2,ncol=2)
PxyStateWIperState
# This will save a file at 300 ppi
ggsave(PxyStateWIperState, file="Winter distribution of states.png",width=12, height=6, dpi=300)

```


## Plot time series by 10 minute intervals
JAF: This is not working.
```{r}
depTimeP<- GPS_states %>%
  arrange(dttz) %>% 
  group_by(season) %>% 
  summarize(lasttime=last(dttz),
            firsttime=first(dttz))

# Summer	last = 2019-02-22 15:58:18	first = 2019-02-21 16:00:17		
timePSU <- seq.POSIXt(from=depTimeP$firsttime[depTimeP$season=="Summer"],
                      to = depTimeP$lasttime[depTimeP$season=="Summer"],
                      by = "2 mins")

# Winter	last = 2018-07-12 11:59:03	first = 2018-07-08 18:30:23
timePWI <- seq.POSIXt(from=depTimeP$firsttime[depTimeP$season=="Winter"],
                      to = depTimeP$lasttime[depTimeP$season=="Winter"],
                      by = "2 mins")

# Select time of interest
tOI <- 1:length(timePSU)
#i=13
for (i in tOI) {

  # Filter Bird locations for that period
  # This is plu or minus 300 seconds from the timeP[i]
  jrOI <- GPS_states %>% 
    filter(dttz<=timePSU[i]+120 & dttz>=timePSU[i]-120 )
  
  # THIS NEEDS LOVE: Do density of points? Smaller points? 
p <- ggmap(myMapSU) + 
  geom_point(data = jrOI,aes(x=long,y=lat, color = state, shape = ID),alpha=1,size=1) +
  scale_color_manual(values = colState4) +
  scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  #oord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude") + 
  ggtitle(sprintf("%s (local)", timePSU[i])) + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +
p
  # This will save a file at 300 ppi
  ggsave(sprintf("Outputs/SummerTWLoggerGPS_%i.png", i ), width=6, height=6, dpi=300)
}
```


## Plots -- directly copied from JRspatial (still need to update)
```{r}
# Distribution of step lengths by season
hist(GPS_states$dist[GPS_states$season=="Summer"],breaks = seq(0,2500,10))

# Step lengths by state per season
bp1 <- GPS_states %>% 
  ggplot() +
  geom_boxplot(aes(x=state,y=dist, color = season)) +
  labs(x="State",
       y = "Distance (m)",
       title = "Step lengths by state per season") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp1
ggsave(bp1, file="Step lengths by state per season.png",width=12, height=8, dpi=300)
# Mean step length per bird per period (still does not account for deployment lengths; i.e. a bird with a 3 day deployment will have 3 periods of day and therefore 3 means for day.
bp2 <- ggplot() +
  geom_boxplot(data = distanceSummary,
             aes(x=astronomical,y=periodmeanDist, color = season))+
  labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by ungrouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp2
ds2<- distanceSummary %>% 
  group_by(season,id,astronomical) %>% 
  summarize(indMeanPeriodDist = mean(periodDist),
            indMeanPeriodMeanDist = mean(periodmeanDist))
# Mean of cumulative distance per bird by astronomical
bp3 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodDist, color = season))+
  labs(x="Period",
       y = "Mean distance (m)",
       title = "Mean cumulative distance per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp3
# Mean of mean step length per bird per astronomical (accounts for deployment lengths; i.e. a bird with a 3 day deployment will have 3 periods of day, find the mean per day and then find a mean across days); This graph is the group mean of individual means.
# This is a mean of 34 means per period
bp4 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodMeanDist, color = season)) +
   labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp5 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodMeanDist, color = season)) +
   labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bpall <- ggarrange(bp1,bp2,bp3,bp4,nrow=2,ncol=2)
# This will save a file at 300 ppi
ggsave(bpall, file="Seasonal Mean Distance and Step Lengths.png",width=12, height=6, dpi=300)
```


## MC random save while showing me R functions

```{r}
foo <- GPS_states %>%
  group_by(state, season) %>% 
  group_split() %>% 
  map(~ ggplot(.x, aes(x, y, color = ID)) +
        geom_point() +
        labs(title = sprintf("%s: State %i", .x$season[[1]], .x$state[1])) +
        theme_classic())

#MAYBE adapt this from DayNightMOvementV2.Rmd
library(adehabitatHR)
library(maptools)
library(viridis)
library(leaflet)
testdf <- GPS_states %>%
  filter(season=="Summer")
astro_SP <- longlat_to_UTM(testdf$long,testdf$lat)
astro_SP_All <-bind_cols(astro_SP,testdf) # combine all data
astro_SP_All <- SpatialPointsDataFrame(cbind(astro_SP$x, astro_SP$y), astro_SP_All, match.ID = FALSE)

#KJH modify the following to match my day/night periods
# astro_SP_Day <- astro_SP_All[astro_SP_All$period %% 4  == 1 ,]
# astro_SP_Dusk <- astro_SP_All[astro_SP_All$period %% 4  == 2 ,]
# astro_SP_Night <- astro_SP_All[astro_SP_All$period %% 4  == 3 ,]
# astro_SP_Dawn <- astro_SP_All[astro_SP_All$period %% 4  == 0 ,]

# make sure the 'period' column is being referenced below (should be 2nd to last column)
# (ud <- kernelUD(astro_SP_All[,ncol(astro_SP_All)-1],h = "href", same4all = TRUE, grid = 1000))
(ud <- kernelUD(astro_SP_All[,3],h = "href", same4all = TRUE, grid = 1000))

# (ud_Day <- kernelUD(astro_SP_Day[,ncol(astro_SP_Day)-1],h = "href", same4all = TRUE, grid = 1000))
# (ud_Night <- kernelUD(astro_SP_Night[,ncol(astro_SP_Night)-1],h = "href", same4all = TRUE, grid = 1000))
# (ud_Dusk <- kernelUD(astro_SP_Dusk[,ncol(astro_SP_Dusk)-1],h = "href", same4all = TRUE, grid = 1000))
# (ud_Dawn <- kernelUD(astro_SP_Dawn[,ncol(astro_SP_Dawn)-1],h = "href", same4all = TRUE, grid = 1000))
## The UD by period
image(ud)
# image(ud_Day)
# image(ud_Night)
# image(ud_Dusk)
# image(ud_Dawn)


overlapUD <- kerneloverlaphr(ud, method = "BA",
                             percent = 95, conditional = FALSE)
```



## Calculate KDE (95 and 50%)

```{r}
# Create spatial points
GPS_statesSP <-   SpatialPointsDataFrame(cbind(GPS_states$x, GPS_states$y), GPS_states, match.ID = FALSE)
# Convert UTM to lat long
crds <-   UTM_to_longlat(GPS_statesSP,20,'south')
colnames(crds) <- c('long','lat')
GPS_states$lat <- crds$lat
GPS_states$long <- crds$long

# For spatial distribution of states, convert state variable to class "factor"
GPS_states$state <-as.factor(GPS_states$state)

# Create coordinate reference system (CRS)
CRSstring <- paste0(
    "+proj=utm +zone=20",
    " +ellps=WGS84",
    " +", "south")

# Attempt to debug dawnT and duskT issue that keeps generating warnings
GPS_states <- GPS_states %>% ungroup()
# GPS_states$duskT <-NULL
# GPS_states$dawnT <-NULL

# Convert lat long to UTM
dataset_SP <- longlat_to_UTM(GPS_states$long,GPS_states$lat)
# Combine GPS spatial data points and state classifications  
dataset_SP_All <-bind_cols(dataset_SP,GPS_states) # combine all data
# Create spatial data point frame
dataset_SP_All <- SpatialPointsDataFrame(cbind(dataset_SP$x, dataset_SP$y), dataset_SP_All, match.ID = FALSE)
# Remove duplicate times
# dataset_SP_All <- dataset_SP_All[!duplicated(dataset_SP_All$dt),] 
# Make sure there are no duplicate times (JAF)
dataset_SP_All$dt[duplicated(dataset_SP_All$dt)] 
# Inputs for AdeHabitatLT Resicretization Function
xy <- coordinates(dataset_SP_All)
id <- dataset_SP_All$name
# da <- dataset_SP_All$dt 
# burstAll <- dataset_SP_All$namePeriod

# This may be a solution to be able to create polygons below. Left off here from working with JAF.
# xy <- dataset[,c(4,3)]
# spdf <- SpatialPointsDataFrame(coords = xy, data = dataset, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))


# MCPs from adehabitatHR
jr_hr_mcp <- mcp.area(dataset_SP_All[,6], percent=c(50,95), unout=c("km2"), plot=F)
mcpFULL <- mcp.area(dataset_SP_All[,6], percent=100, unout=c("km2"), plot=F)
mcpFULL <- as.data.frame(t(mcpFULL))
mcpFULL$season <- c("Summer","Summer","Summer","Winter","Summer", "Winter","Winter","Winter","Winter","Summer","Summer","Summer")
colnames(mcpFULL) <- c("mcp","season")
mmcpFULL <- mean(mcpFULL$mcp[mcpFULL$season=="Summer"])

# write_csv(jr_hr_mcp)

# create the utilization distribution
jr_hr_kde_UD <- kernelUD(dataset_SP_All[,6], h="href", grid=500, same4all=TRUE)
image(jr_hr_kde_UD)


# get our core and HR estimates based on the UD
jr_hr_kde <- kernel.area(jr_hr_kde_UD, percent=c(50, 95), unout=c("km2"))

kde <- as.data.frame(t(jr_hr_kde))
colnames(kde) <- c("kdef","kdenf")
kde$season <- c("Summer","Summer","Summer","Winter","Summer", "Winter","Winter","Winter","Winter","Summer","Summer","Summer")
mkdeSU95 <- mean(kde$kdenf[kde$season=="Summer"])
sdkdeSU95 <- sd(kde$kdenf[kde$season=="Summer"])
mkdeSU50 <- mean(kde$kdef[kde$season=="Summer"])
sdkdeSU50 <- sd(kde$kdef[kde$season=="Summer"])
mkdeWI95 <- mean(kde$kdenf[kde$season=="Winter"])
sdkdeWI95 <- sd(kde$kdenf[kde$season=="Winter"])
mkdeWI50 <- mean(kde$kdef[kde$season=="Winter"])
sdkdeSWI50 <- sd(kde$kdef[kde$season=="Winter"])

test <- kernelUD(dataset_SP_All[,6], h="href", grid=1000, same4all=TRUE)
kdeFULL <- kernel.area(test, percent=100, unout=c("km2"))


# create our polygon of the HR
hr_kde_poly <- getverticeshr(jr_hr_kde_UD, percent=95)
hr_kde_latlong <- spTransform(hr_kde_poly, CRS("+proj=utm +zone=20 +ellps=WGS84 +south +units=m"))

# compare mcp and kde estimates
hr <- data.frame(jr_hr_mcp,jr_hr_kde)

write.csv(hr, file="HR.csv", row.names = FALSE)

```

