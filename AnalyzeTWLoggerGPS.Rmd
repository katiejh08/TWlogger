---
title: "AnalyzeTWLoggerGPS"
author: "Katie Harrington"
date: "April 21, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Get Started
*This file takes ... and does ...

## Load libraries; set working directory and local time zone offset
*NOTE: Saunders is in UTM20S 
```{r echo=FALSE, warning=FALSE}
library(tidyverse)
library(dplyr)
library(maptools) # to calculate solarpos
library(stringr)
library(lubridate)
library(adehabitatLT)
#library(argosfilter)
library(geosphere)
library(ggpubr)
library(sp)
library(rgdal)
library(tibble)
library("rnaturalearth")
library("rnaturalearthdata")
library("sf")
library("ggspatial")
library(marmap)
library(mapdata)
library(metR)
source('UTMConversionfxns.R')
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(rstudioapi)
library(argosfilter)
library(tidyverse)
library(lubridate)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(devtools)
library(RColorBrewer)
# if(!requireNamespace("devtools")) 
# install.packages("devtools")
# devtools::install_github("dkahle/ggmap")
register_google(key = "AIzaSyAHRpFoa86K8IXnsIo1H3fLjWyhorawZew")
has_google_key()

# Set the Working Directory
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path ))
rm(current_path)
getwd()

tzOffset <-"Etc/GMT+3"
```

## Combine Data and calculate summary stats
```{r warnings=FALSE}
# Select file to import
filename <- file.choose()
# Import IGU GPS data (ScriptOutputs from KML builder scripts)
pathChoice <- dirname(filename)
# This imports all CSV files in the directory chosen
filenames <- list.files(path = pathChoice, pattern = "*.csv", all.files = FALSE, full.names = TRUE, recursive = FALSE, ignore.case = TRUE)

# Load deployment times from CSV
depTimes <- read_csv(paste0(getwd(),"/depTimes.csv"))
depTimes$startTime <- as.POSIXct(strptime(depTimes$startTime,format="%m/%d/%Y %H:%M"),tz=tzOffset)
depTimes$endTime <- as.POSIXct(strptime(depTimes$endTime,format="%m/%d/%Y %H:%M"),tz=tzOffset)

# Create an empty dataframe to hold all the data
dataset = data.frame()
# Iteratively import CSV files from each deployment, find sunrise and sunset times, and create columns for sorting and processing.
for(i in 1:length(filenames)) {
  data <- read_csv(filenames[i],
                   col_types = cols(TimeUTC = col_character(),
                                    Lat = col_double(),
                                    Long = col_double()))
  # select only columns with name, lat, long, etc.
  data <- data[,c("Lat","Long","DateUTC","TimeUTC")]
   # extract deployment name from filename
  name <- strsplit(filenames[i],"[.]")[[1]][1] # This removes the .CSV
  name <- str_replace_all(name,"\\\\","/") # this makes it work for both windows and mac
  name <- sapply(strsplit(name,"[/]"),tail,1) # Take just the filename
  name <- sapply(strsplit(name,"[_]"),tail,1) # Take just the filename
  name <- sapply(strsplit(name,"[-]"),head,1) # Take just the filename
  data$name <- name
  # Create DateTime (UTC)
  data$dt  <- as.POSIXct(strptime(paste(data$DateUTC, data$TimeUTC,sep=" "),format = "%m/%d/%Y %H:%M:%S"), tz="GMT")
  attr(data$dt, "tzone") # Check tz
   # select only columns with name, lat, long, etc.
  data <- data[,c("name","dt", "Lat","Long")]
  colnames(data) <- c("name","dt","lat","long")
  # Convert to local time
  data$dttz <- data$dt # set dttz to dt
  attr(data$dttz, "tzone") <- tzOffset # change the timezone to tzOffset
  data <- data %>% arrange(dttz)
  startTime <- depTimes %>% filter(ID == name) %>% .$startTime
  endTime <- depTimes %>% filter(ID == name) %>% .$endTime
  data <- subset(data, data$dttz >= startTime & data$dttz <= endTime)

  # Create useful identifiers
  data$date <- as.Date(data$dttz, tz = tzOffset)
  data$yr <- year(data$dttz)
  data$mth <- month(data$dttz)
  data$hr <- hour(data$dttz)	
  data$yday <- yday(data$dttz)
  data$yday <- sprintf('%03d',data$yday)
  data$yday <- paste('D',data$yday,sep='')
  data$indday <- as.factor(paste(data$name, data$yday, sep ='_', collapse = NULL))

  # Calculate distance between consecutive points
  source('Point2Point-stats.R')
  # Determine Solar Position for each point
  source('SunriseSunsetTimes.R')
  
  data <- data %>%
  arrange(dttz) %>%
  #Tidy up some unused columns
  mutate(period = cumsum(replace_na(lag(astronomical) != astronomical, 1)),  
         cycle = floor(period / 4))
  #convert dur (time between consecutive points) to minutes
  data$dur <- data$dur*60 
  # Combine into Dataset
  if(i==1) dataset <- data else dataset <- rbind(dataset,data)
}

# Check for NAs
sapply(dataset, function(x) sum(is.na(x)))
# cleanup
rm(v1, v2, v3,xy, i, name,data)
```

## Rediscretize data
*Saves rediscretized data (2min) as redist_Astro.RData
```{r}
# add unique identifier to group by name and period in plots
dataset$namePeriod <- paste(dataset$name, dataset$period, sep = "-")
#### Rediscretize Data ####
dataset_SP <- longlat_to_UTM(dataset$long,dataset$lat)
dataset_SP_All <-bind_cols(dataset_SP,dataset) # combine all data
dataset_SP_All <- SpatialPointsDataFrame(cbind(dataset_SP$x, dataset_SP$y), dataset_SP_All, match.ID = FALSE)
dataset_SP_All <- dataset_SP_All[!duplicated(dataset_SP_All$dt),] # remove duplicate times
# make sure there are no duplicate times (JAF)
dataset_SP_All$dt[duplicated(dataset_SP_All$dt)] 
# Inputs for AdeHabitatLT Resicretization Function
xy <- coordinates(dataset_SP_All)
id <- dataset_SP_All$name
da <- dataset_SP_All$dt
burstAll <- dataset_SP_All$namePeriod 

# Create a Trajectory (used in Rediscretization function)
# burst allows each period to be rediscretized individually
litr <- as.ltraj(xy, da, burst = burstAll, id,  typeII = TRUE)
#head(litr)
plot(litr)
## Rediscretize Trajectories
reLitr <- redisltraj(litr, 120, burst = burst, type = "time") # 120 seconds is 2 minutes
reLitr5min<- redisltraj(litr, 300, burst = burst, type = "time") # 300 seconds is 5 minutes
#head(reLitr)
plot(reLitr)
# Convert to Dataframe
rediscretized_data <- ld(reLitr)
rediscretized_data5min <- ld(reLitr5min)


dataset_sum <- dataset %>% 
  subset(.,select = c(astronomical, cycle, period, namePeriod)) %>% 
  distinct %>% 
  mutate(namePeriod = as.factor(namePeriod))
class(dataset_sum$namePeriod)
class(rediscretized_data$burst)

# Join dataset to rediscretized data
redist_Astro <- left_join(rediscretized_data, 
                         dplyr::select(dataset_sum, namePeriod, cycle, period, astronomical), by = c("burst"="namePeriod"))
redist_Astro <- redist_Astro %>% arrange(id,cycle,period)
redist_Astro$mth <- month(redist_Astro$date)
attr(redist_Astro$date, "tzone")
redist_Astro$dt <- redist_Astro$date
redist_Astro$dttz <- redist_Astro$dt
attr(redist_Astro$dttz, "tzone") <- tzOffset # change the timezone to tzOffset
redist_Astro$yday <- yday(redist_Astro$dttz)
redist_Astro <- redist_Astro %>% 
  group_by(season,id) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup
redist_Astro$ID <- redist_Astro$id
redist_Astro$id <- NULL
# Determine Season (calculated from 2017 solstices and equinoxes)
redist_Astro$season <- rep('NA')
redist_Astro[which(redist_Astro$yday > 79 & redist_Astro$yday <= 171),]$season <- 'Fall'
redist_Astro[which(redist_Astro$yday > 171 & redist_Astro$yday <= 265),]$season <- 'Winter'
redist_Astro[which(redist_Astro$yday > 265 & redist_Astro$yday < 355),]$season <- 'Spring'
redist_Astro[which(redist_Astro$yday >= 355 | redist_Astro$yday <= 79),]$season <- 'Summer'
unique(redist_Astro$season)
distanceSummary <- redist_Astro %>% 
  group_by(season, ID,dayNight) %>% 
  summarize(periodDist = sum(dist,na.rm = TRUE),
            periodmeanDist = mean(dist,na.rm = TRUE),
            periodSDdist = sd(dist,na.rm = TRUE))
save(redist_Astro,file="redist_Astro.RData")
```

## Add states to GPS
```{r}
# Load R workspace
load("~/Projects/R/TWlogger/data_states.RData")
FullAccStatesGPS <- left_join(data_states, redist_Astro, by = c("ID","dttz"))

# Function for getting the mode of a vector
mode <- function(x) {
  unique_x <- unique(x)
  unique_x[which.max(tabulate(match(x, unique_x)))]
}

# columns of interest are ID, dttz, state_classif, x, y
FullAccStatesGPS2 <- FullAccStatesGPS %>% 
  group_by(ID) %>% 
  # This associates each acceleration value with the following GPS hit
  mutate(gps_hit = lag(cumsum(!is.na(x)), default = 0))

# Just the GPS data
GPS_data <- FullAccStatesGPS2 %>% 
  drop_na(date.y) %>% 
  dplyr::select(ID, gps_hit, dt, dttz, x, y)

GPS_states <- FullAccStatesGPS2 %>% 
  # For each bird's GPS hit...
  group_by(ID, gps_hit) %>% 
  # Find the state mode for the associated acceleration values
  summarize(state = mode(state_classif)) %>% 
  # Join GPS data 
  left_join(GPS_data, by = c("ID", "gps_hit")) %>% 
  drop_na(dttz) 
# rm(FullAccStatesGPS2)
# rm(GPS_data)
# GPS_data <- GPS_data %>% 
GPS_statesSP <-   SpatialPointsDataFrame(cbind(GPS_states$x, GPS_states$y), GPS_states, match.ID = FALSE)
crds <-   UTM_to_longlat(GPS_statesSP,20,'south')
colnames(crds) <- c('long','lat')
GPS_states$lat <- crds$lat
GPS_states$long <- crds$long
GPS_states$state <-as.factor(GPS_states$state)

# Recalculate astronomical
data <- GPS_states
# Create useful identifiers
data$date <- as.Date(data$dttz, tz = tzOffset)
data$yr <- year(data$dttz)
data$mth <- month(data$dttz)
data$hr <- hour(data$dttz)	
data$yday <- yday(data$dttz)
data$yday <- sprintf('%03d',data$yday)
data$yday <- paste('D',data$yday,sep='')
data$indday <- as.factor(paste(data$name, data$yday, sep ='_', collapse = NULL))
source('SunriseSunsetTimes.R')
GPS_states <- data
# Determine Season (calculated from 2017 solstices and equinoxes)
GPS_states$yday <- yday(GPS_states$dttz)
GPS_states$season <- rep('NA')
GPS_states[which(GPS_states$yday > 79 & GPS_states$yday <= 171),]$season <- 'Fall'
GPS_states[which(GPS_states$yday > 171 & GPS_states$yday <= 265),]$season <- 'Winter'
GPS_states[which(GPS_states$yday > 265 & GPS_states$yday < 355),]$season <- 'Spring'
GPS_states[which(GPS_states$yday >= 355 | GPS_states$yday <= 79),]$season <- 'Summer'
unique(GPS_states$season)

#Combine astronomical to day and night
GPS_states <- GPS_states %>% 
  group_by(season,ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"Day","Night")) %>%
  ungroup
```

## Data filters for plotting GPS positions with state classifications
```{r echo=FALSE, warnings=FALSE}
# Filter summer by day and night
xyStateSUd <- GPS_states %>%
  filter(season=="Summer",
         dayNight=="Day")
xyStateSUn <- GPS_states %>%
  filter(season=="Summer",
         dayNight=="Night")

# Filter summer by states
xyStateSU4 <- GPS_states %>%
  filter(season=="Summer",
         state=="4")
xyStateSU3 <- GPS_states %>%
  filter(season=="Summer",
         state=="3")
xyStateSU2 <- GPS_states %>%
  filter(season=="Summer",
         state=="2")
xyStateSU1 <- GPS_states %>%
  filter(season=="Summer",
         state=="1")

# Filter by winter
xyStateWI <- GPS_states %>%
  filter(season=="Winter")

# Filter winter by states
xyStateWI4 <- GPS_states %>%
  filter(season=="Winter",
         state=="4")
xyStateWI3 <- GPS_states %>%
  filter(season=="Winter",
         state=="3")
xyStateWI2 <- GPS_states %>%
  filter(season=="Winter",
         state=="2")
xyStateWI1 <- GPS_states %>%
  filter(season=="Winter",
         state=="1")



# Set zoom. Adjust this to fit all the data (20 is all the way zoomed in)
mapZoomSU <- 14 
mapZoomWI <- 12 

# Plot the extent of this map (NOTE: must adjust zoom parameter)
myMapSU <-  get_googlemap(center = c(lon = mean(c(min(xyStateSU$long), max(xyStateSU$long))),  
                                   lat = mean(c(min(xyStateSU$lat),max(xyStateSU$lat)))),
                        zoom = mapZoomSU, 
                        scale = 2,
                        extent="device",
                        maptype="hybrid", #"terrain"
                        style = c(feature = "all", element = "labels", visibility = "off"))
myMapWI <-  get_googlemap(center = c(lon = mean(c(min(xyStateWI$long), max(xyStateWI$long))),  
                                   lat = mean(c(min(xyStateWI$lat),max(xyStateWI$lat)))),
                        zoom = mapZoomWI, 
                        scale = 2,
                        extent="device",
                        maptype="hybrid", #"terrain"
                        style = c(feature = "all", element = "labels", visibility = "off"))
# State Colors (4 states)
colState4 <- c("4" = "#B2182B", "3" = "#F4A582", "2" = "#92C5DE", "1"= "#2166AC")
# State Colors (2 states)
colState2 <- c("4" = "#B2182B", "3" = "#B2182B", "2" = "#2166AC", "1"= "#2166AC")

shapeSU <- c("B50"=0, "C51"=1, "G53"=2, "M57"=3, "X56"=4, "Z55"=5, "Z59"=6)

# THIS NEEDS LOVE: Do density of points? Smaller points? 
PxyStateSUd <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUd,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer daytime distribution of states") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyStateSUd

PxyStateSUn <- ggmap(myMapSU) + 
  geom_point(data = xyStateSUn,aes(x=long,y=lat, color = state),alpha=0.8,size=0.8) +
  scale_color_manual(values = colState4) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer nighttime distribution of states") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +
  # facet_wrap(~ ID, nrow=3)
# PxyStateSUn

PxyStateSU <- ggarrange(PxyStateSUd,PxyStateSUn,nrow=2)
```


## Create Summer plots, one per state, colored by ID
```{r}
PxyStateSU4 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU4,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y="Latitude",
       title = "Summer distribution of state 4") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU4
PxyStateSU3 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU3,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 3") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU3
PxyStateSU2 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU2,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 2") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU2
PxyStateSU1 <- ggmap(myMapSU) + 
  geom_point(data = xyStateSU1,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Summer distribution of state 1") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateSU4

PxyStateSUperState <- ggarrange(PxyStateSU1,PxyStateSU2,PxyStateSU3,PxyStateSU4,nrow=2,ncol=2)
PxyStateSUperState
# This will save a file at 300 ppi
ggsave(PxyStateSUperState, file="Summer distribution of states.png",width=12, height=6, dpi=300)
```


## Create winter plots, one per state, colored by ID
```{r}
PxyStateWI4 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI4,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y="Latitude",
       title = "Winter distribution of state 4") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI4
PxyStateWI3 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI3,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 3") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI3
PxyStateWI2 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI2,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 2") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI2
PxyStateWI1 <- ggmap(myMapWI) + 
  geom_point(data = xyStateWI1,aes(x=long,y=lat, color = ID),alpha=1,size=0.8) +
  scale_alpha(guide = 'none') +
  coord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude",
       title = "Winter distribution of state 1") + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PxyStateWI1

PxyStateWIperState <- ggarrange(PxyStateWI1,PxyStateWI2,PxyStateWI3,PxyStateWI4,nrow=2,ncol=2)
PxyStateWIperState
# This will save a file at 300 ppi
ggsave(PxyStateWIperState, file="Winter distribution of states.png",width=12, height=6, dpi=300)

```

## Plot time series by 10 minute intervals
```{r}
depTimeP<- GPS_states %>%
  arrange(dttz) %>% 
  group_by(season) %>% 
  summarize(lasttime=last(dttz),
            firsttime=first(dttz))

# Summer	last = 2019-02-22 15:58:18	first = 2019-02-21 16:00:17		
timePSU <- seq.POSIXt(from=depTimeP$firsttime[depTimeP$season=="Summer"],
                      to = depTimeP$lasttime[depTimeP$season=="Summer"],
                      by = "2 mins")

# Winter	last = 2018-07-12 11:59:03	first = 2018-07-08 18:30:23
timePWI <- seq.POSIXt(from=depTimeP$firsttime[depTimeP$season=="Winter"],
                      to = depTimeP$lasttime[depTimeP$season=="Winter"],
                      by = "2 mins")

# Select time of interest
tOI <- 1:length(timePSU)
#i=13
for (i in tOI) {

  # Filter Bird locations for that period
  # This is plu or minus 300 seconds from the timeP[i]
  jrOI <- GPS_states %>% 
    filter(dttz<=timePSU[i]+120 & dttz>=timePSU[i]-120 )
  
  # THIS NEEDS LOVE: Do density of points? Smaller points? 
p <- ggmap(myMapSU) + 
  geom_point(data = jrOI,aes(x=long,y=lat, color = state, shape = ID),alpha=1,size=1) +
  scale_color_manual(values = colState4) +
  scale_shape_manual(values = shapeSU) + 
  scale_alpha(guide = 'none') +
  #oord_fixed(1.3) +
  labs(x="Longitude",
       y = "Latitude") + 
  ggtitle(sprintf("%s (local)", timePSU[i])) + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))# +
p
  # This will save a file at 300 ppi
  ggsave(sprintf("Outputs/SummerTWLoggerGPS_%i.png", i ), width=6, height=6, dpi=300)
}
```





## Plots -- directly copied from JRspatial (still need to update)
```{r}
# Cumulative distance per bird per period
bp1 <- ggplot() +
  geom_boxplot(data = distanceSummary,
             aes(x=dayNight,y=periodDist, color = season)) +
  labs(x="Period",
       y = "Distance (m)",
       title = "Cumulative distance per bird by day and night") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp1
# Mean step length per bird per period (still does not account for deployment lengths; i.e. a bird with a 3 day deployment will have 3 periods of day and therefore 3 means for day.
bp2 <- ggplot() +
  geom_boxplot(data = distanceSummary,
             aes(x=astronomical,y=periodmeanDist, color = season))+
  labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by ungrouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp2
ds2<- distanceSummary %>% 
  group_by(season,id,astronomical) %>% 
  summarize(indMeanPeriodDist = mean(periodDist),
            indMeanPeriodMeanDist = mean(periodmeanDist))
# Mean of cumulative distance per bird by astronomical
bp3 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodDist, color = season))+
  labs(x="Period",
       y = "Mean distance (m)",
       title = "Mean cumulative distance per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp3
# Mean of mean step length per bird per astronomical (accounts for deployment lengths; i.e. a bird with a 3 day deployment will have 3 periods of day, find the mean per day and then find a mean across days); This graph is the group mean of individual means.
# This is a mean of 34 means per period
bp4 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodMeanDist, color = season)) +
   labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bp5 <- ggplot() +
  geom_boxplot(data = ds2,
             aes(x=astronomical,y=indMeanPeriodMeanDist, color = season)) +
   labs(x="Period",
       y = "Mean step length (m)",
       title = "Mean step length per bird by grouped periods") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))#,
        #legend.position="none")
bpall <- ggarrange(bp1,bp2,bp3,bp4,nrow=2,ncol=2)
# This will save a file at 300 ppi
ggsave(bpall, file="Seasonal Mean Distance and Step Lengths.png",width=12, height=6, dpi=300)
```


```{r}
foo <- GPS_states %>%
  group_by(state, season) %>% 
  group_split() %>% 
  map(~ ggplot(.x, aes(x, y, color = ID)) +
        geom_point() +
        labs(title = sprintf("%s: State %i", .x$season[[1]], .x$state[1])) +
        theme_classic())
```

