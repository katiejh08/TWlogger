---
title: "Striated Caracara"
subtitle: "ODBA and Activity Budget Analysis"
author: "Katie Harrington"
date: "April 19, 2019"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
     collapsed: false
     smooth_scroll: false
    df_print: paged
---
##

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Get Started
This loads libraries, sets working directory, and creates local time zone offset.

#### Set up environment



```{r Libraries,echo=FALSE,results="hide",warning=FALSE,collapse=TRUE}

library(tidyverse)
library(dplyr)
library(maptools) # to calculate solarpos
library(stringr)
library(lubridate)
library(adehabitatLT)
library(geosphere)
library(ggpubr)
library(sp)
library(rgdal)
library(tibble)
library("rnaturalearth")
library("rnaturalearthdata")
library("sf")
library("ggspatial")
library(marmap)
library(mapdata)
library(metR)
library(RcppRoll)
library(plotrix)

# setwd("~/Projects/R/TWlogger")
tzOffset <-"Etc/GMT+3"
```

#### Prep Data
This imports and combines data frames to produce data_states.Rdata. Only need to run this section once, unless needing to recreate data_states.Rdata.


##### Import HMM states
This imports data with HMM states and runs SunriseSunsetTimes.r.


```{r DataImport,warning=FALSE,results="hide",message=FALSE}

# Load R workspace
load("data_with_states.RData")
# Combine list into one dataframe
data <-bind_rows(data_with_states)
rm(data_with_states)
# Create Spatial Points
data$long <- -60.09
data$lat <- -51.37

# Check dttz 
attr(data$dttz, "tzone") #Check tz
attr(data$dttz, "tzone") <- tzOffset

data$date <- as.Date(data$dttz, tz = tzOffset)

# Run the sunrise sunset script
source('SunriseSunsetTimes.r')
# Check for NAs
sapply(data, function(x) sum(is.na(x)))
# Determine Season (calculated from 2018 solstices and equinoxes)
data$yday <- yday(data$dttz)
data$season <- rep('NA')
#data[which(data$yday > 79 & data$yday <= 173),]$season <- 'Fall'
data[which(data$yday > 173 & data$yday <= 265),]$season <- 'Winter'
#data[which(data$yday > 265 & data$yday < 355),]$season <- 'Spring'
data[which(data$yday >= 355 | data$yday <= 79),]$season <- 'Summer'
data$season <- as.factor(data$season)
unique(data$season)

# Rename data
data_states <-data
rm(data)
```

##### Import Raw Acc, combine with HMM states, calculate ODBA
This creates one file that includes states and raw acc. Saves as data_states.Rdata.


```{r Combine,warning=FALSE,results="hide",message=FALSE}
# load Final Metrics from AnalyzeFinalAccV1
load("~/Projects/R/TWlogger/FinalMetrics.RData")
# Add acc data to stateData
data_states <- left_join(data_states,dplyr::select(data,ID,dttz,Ax,Ay,Az), by = c("ID","dttz"))
rm(data)
# Consolidate astronomical periods two periods (day and night)
data_states <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup
# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

# Create SolarMidnight based hourly bins
data_states$solarMidnight <- hms::as.hms((data_states$solarnoon- dhours(12)),tz = tzOffset)
data_states$time <- hms::as.hms(data_states$dttz,tz = tzOffset)
data_states$timeBin <- floor(as.numeric(difftime(data_states$time, data_states$solarMidnight,units = "hours")))
data_states$timeBin <- ifelse(data_states$timeBin < 0,data_states$timeBin+24,data_states$timeBin)
data_states$hr <- hour(data_states$dttz)
data_states$night <- NULL

# Recalculate ODBA (ms-2)
# Calculate static (running mean)
windowSize=11 
data_states <- data_states %>% 
  arrange(ID,dttz) %>% 
  group_by(ID) %>% 
  mutate(static_Ax=roll_mean(Ax,windowSize,fill=NA),
         static_Ay=roll_mean(Ay,windowSize,fill=NA),
         static_Az=roll_mean(Az,windowSize,fill=NA)) %>%
  ungroup

# Replace the NA's at the beginning with the first good value
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>%
  mutate(naUp = ifelse(row_number()<=(windowSize-1)/2+1,1,0),
         naDown = ifelse(row_number() > n() - ((windowSize-1)/2+1),1,0)) %>%# View
  ungroup %>% 
  group_by(ID,naUp) %>% 
  mutate(static_Ax = ifelse(naUp == 1,last(static_Ax),static_Ax),
         static_Ay = ifelse(naUp == 1,last(static_Ay),static_Ay),
         static_Az = ifelse(naUp == 1,last(static_Az),static_Az)) %>% 
  ungroup %>% 
  group_by(ID,naDown) %>% 
  mutate(static_Ax = ifelse(naDown == 1,first(static_Ax),static_Ax),
         static_Ay = ifelse(naDown == 1,first(static_Ay),static_Ay),
         static_Az = ifelse(naDown == 1,first(static_Az),static_Az)) %>% 
  ungroup
data_states$naUp <- NULL
data_states$naDown <- NULL

# Calculate dynamic (raw-static) and ODBA (sum abs dynamic)
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>% 
  mutate(dyn_Ax=Ax-static_Ax,
         dyn_Ay=Ay-static_Ay,
         dyn_Az=Az-static_Az,
         ODBA=abs(dyn_Ax+dyn_Ay+dyn_Az)) %>% 
  ungroup #%>% View

data_states$ODBA <- data_states$ODBA
data_states$state <-ifelse(data_states$state_classif==1|data_states$state_classif==2,"Rest","Active")
data_states$yr <- year(data_states$dttz)
data_states$dawnT <- hour(data_states$dawn) + second(data_states$dawn)/60
data_states$duskT <- hour(data_states$dusk) + second(data_states$dusk)/60


# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

# save(data_states,file="data_states.RData")
```

### Analyze Data
Begin here to continue analysis below. This loads data_states.Rdata which contains ODBA values and state class identified by 4-state HMM.


```{r Load, echo=FALSE,warnings=FALSE}
load("data_states.RData")

```


#### Calculate 4-state counts and proportions by astronomical period
This creates stateSummaryIND.


```{r stateSummaryIND, warnings=FALSE}
# Calculate state count and proportions by 4 periods (dawn, day, dusk, night)
stateSummaryIND <- data_states %>% 
  group_by(season, ID, astronomical) %>% 
  mutate(periodLength = n()) %>% 
  ungroup %>% 
  group_by(season, ID, astronomical, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateProp = stateCount/periodLength) %>% 
  ungroup

# Change classes for plotting
stateSummaryIND$ID <- as.factor(stateSummaryIND$ID)
stateSummaryIND$astronomical <- as.factor(stateSummaryIND$astronomical)

# Create vectors to retain groupings for plots
stateSummaryIND$season_per_state <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,
                                          stateSummaryIND$state_classif,sep="_")
stateSummaryIND$season_period <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,sep="_")
```

#### Calculate 4-state and 2-state counts and proportions by day and night
This creates stateSummaryIND2period, stateSummaryIND2period2state, dayActive, and dayRest.

```{r stateSummaryIND2period, warning=FALSE}
# 4-state, 2 period
# Create new dataframe that combines astronomical periods into day and night and calculates 4-state counts and proportions
stateSummaryIND2period <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight) %>% 
  mutate(periodLength = n()) %>%
  ungroup %>% 
  group_by(season, ID, dayNight, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateCountMin = stateCount/60,
         stateCountHour = stateCount/60/60,
         stateProp = stateCount/periodLength) %>% 
  ungroup

# Create vectors to retain groupings for plots
stateSummaryIND2period$ID <- as.factor(stateSummaryIND2period$ID)
stateSummaryIND2period$dayNight <- as.factor(stateSummaryIND2period$dayNight)
stateSummaryIND2period$season_per_state <- paste(stateSummaryIND2period$season,
                                          stateSummaryIND2period$dayNight,
                                          stateSummaryIND2period$state_classif,sep="_")
stateSummaryIND2period$season_period <- paste(stateSummaryIND2period$season,
                                       stateSummaryIND2period$dayNight,sep="_")
stateSummaryIND2period$state_classif <- as.factor(stateSummaryIND2period$state_classif)

# 2-state, 2 period
# Create new dataframe that combines active and rest states and calculates 2-state count and proportions
stateSummaryIND2period2state <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif) %>%
  mutate(state = ifelse(state_classif %in% c("1","2"),"rest","active")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight,state,periodLength) %>% 
  summarize(stateCount2state = sum(stateCount)) %>% 
  mutate(stateCountMin = stateCount2state/60,
         stateCountHour = stateCount2state/60/60,
         stateProp = stateCount2state/periodLength) %>% 
  ungroup

# Create dataframe of only daytime active state
dayActive <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="active") 

# Create dataframe of only daytime resting state
dayRest <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="rest") 
```

#### Justify nighttime exclusion from analysis.
These data suggest a diel pattern between seasons with over 95% of nighttime during both seasons spent in the resting state. This implies that the difference in overall ODBA totals in a 24-hr period are being represented in the daytime. 


```{r restPropSU, warning=FALSE}
# % Time spent resting during night
restPropSU <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight,state) %>% 
  summarize(stateProp = mean(stateProp))
```


```{r PnightDur, warning=FALSE}
# Plot nighttime absolute state durations
PnightDur <- stateSummaryIND2period2state %>% #View
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>% 
  ggplot() +
  geom_boxplot(aes(x = state, y = stateCountHour,color = season)) +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 24, by = 2)) +
  labs(x="State",
       y = "Duration (hr)",
       title = "Seasonal nighttime state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Plot nighttime state proportions
PnightProp <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>% 
  ggplot() +
  geom_boxplot(aes(x = state, y = stateProp, color = season)) +
  ylim(0,1) +
  labs(x="State",
       y = "Proportion (%)",
       title = "Seasonal nighttime state proportions") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Stack plots to compare full cycle
PnightDurProp <- ggarrange(PnightDur,PnightProp,nrow=2)
PnightDurProp
rm(PnightDur,PnightProp,PnightDurProp)

# Save a file at 300 ppi
# ggsave(PnightDurProp, file="Seasonal nighttime state absolute durations and proportions.png",width=8, height=8, dpi=300)
```

###Q1: Is there a seasonal difference in daily ODBA?

#### Calculate total daily ODBA (g) per individual
This creates sumODBA which contains total daily ODBA for all individuals across years. This also creates dataframes by season (sumODBASU and sumODBAWI).

```{r sumODBA,warning=FALSE}
# Calculate daily ODBA (g) totals per ID
sumODBA <- data_states %>% 
  group_by(yr,season,ID) %>%
  summarize(sumODBA = sum(ODBA/9.81,na.rm = TRUE)) # convert ODBA from ms-2 to g (divide by 9.81)

# Create dataframes of seasonal daily ODBA (g) totals
sumODBASU <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Summer") 

sumODBAWI <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Winter") 
```



#### Confirm pooling seasons across years
This tests for differences in total ODBA per year. If there is no interannual difference by seasons, this by default confirms there are no effects from tag versioning. There is no difference in total ODBA per season between years (summer p=0.83, winter p=0.11). Based on zero-normalized density distributions and the shapiro test for normality, I used t-tests to confirm pooling seasons among years.



```{r pool,warning=FALSE}
# Plot density distributions
dSU <- density(sumODBASU$sumODBA-mean(sumODBASU$sumODBA))
plot(dSU)
dWI <- density(sumODBAWI$sumODBA-mean(sumODBAWI$sumODBA))
plot(dWI)

# Test for normality
shapiro.test(sumODBASU$sumODBA)
shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ yr,data=sumODBASU) #Variance is equal
var.test(sumODBA ~ yr,data=sumODBAWI) #Variance is equal

# Test for differences within each season by year to confirm pooling
t.test(sumODBA ~ yr, data=sumODBASU,var.equal = TRUE)
t.test(sumODBA ~ yr, data=sumODBAWI,var.equal = TRUE)

rm(dSU,dWI)
```



#### Test for seasonal differences in total daily ODBA (g)
Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).



```{r ttestODBAdiff,warning=FALSE}
# Test for normality
shapiro.test(sumODBASU$sumODBA)
shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ season,data=sumODBA) #Variance is equal

# Test for seasonal differences
test <- t.test(sumODBA ~ season,data=sumODBA,var.equal = TRUE)
test

sd(sumODBASU$sumODBA)
sd(sumODBAWI$sumODBA)
```

#### Alternative test for seasonal differences
This uses a general lineral model to test for year effects on seasonal differences. There were no effects, so I removed year from the model. It's a more elegant analysis than using a t-test to validate seasonal pooling and another t-test for seasonal differences.



```{r glmODBAdiff}
m1 <- glm(sumODBA~season + (1|yr),data=sumODBA)
summary(m1) # m1 gives NAs because don't have all seasons for all years
m2 <- glm(sumODBA~yr*season, data=sumODBA)
summary(m2)
m3 <- glm(sumODBA~season, data=sumODBA)
summary(m3)
# Results: No effect of year, so can run just by season. Additive model. Removing insignificant variables (e.g. year)
```



#### Figure 1: Seasonal differences in daily ODBA totals by solar hour

```{r ODBAplot, warning=FALSE}
# Meanline summer
meanlineSU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))
# Meanline winter
meanlineWI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))

# Calculate time of mean dawn and dusk and create dataframes to use for shading bins in total daily ODBA plot
shadeSU = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Summer"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Summer"])),23),
                     y1=c(0,0),
                     y2=c(800,800))
shadeWI = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Winter"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Winter"])),23),
                     y1=c(0,0),
                     y2=c(800,800))

# Summer total ODBA per solar hour
PodbaSum24SU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin,dayNight) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7) +
  geom_line(data=meanlineSU,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  ylim(0,800) +
  scale_x_continuous(breaks = seq(0,23, by = 1)) +
  labs(x="Solar Hour",
       y = NULL,
       title = "(b)") + 
  geom_rect(data=shadeSU, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PodbaSum24SU

# Winter total ODBA per solar hour
PodbaSum24WI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7)+
  geom_line(data=meanlineWI,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  ylim(0,800) +
  scale_x_continuous(breaks = seq(0,23, by = 1)) +
  labs(x=NULL,
       y = NULL,
       title = "(a)") + 
  geom_rect(data=shadeWI, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PodbaSum24WI

Podba24Seas <- ggarrange(PodbaSum24WI,PodbaSum24SU,nrow=2)
Podba24Seas <- annotate_figure(Podba24Seas,
               top = text_grob("Seasonal total ODBA by solar hour", color = "black", size = 14, just="right"),
               #bottom = text_grob("Figure 1. Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).", color = "black",hjust = 1, x = 1, size = 10)#,
               left = text_grob("Total ODBA (g)", color = "black", rot = 90)
)

Podba24Seas
rm(meanlineSU,meanlineWI,PodbaSum24SU,PodbaSum24WI)
# Save a file at 300 ppi
# ggsave(Podba24Seas, file="Seasonal total ODBA per solar hour_shaded.png",dpi=300)
```


### Q2a: Is there a seasonal difference in daytime absolute duration of the active state?

#### Test for seasonal differences in daytime total activity
Pooling the active and resting states masked the seasonal differences in activity. There is no seasonal difference in total time spent in the active state (winter = 5.48 ± 2.18 hr, summer = 5.19 ± 2.38 hr [mean ± SD]; Two Sample t-test, p=0.75).

```{r durdiff, warning=FALSE}
## Test for differences in daytime absolute duration of active state by season

# Test for normality
shapiro.test(dayActive$stateCountHour[dayActive$season=="Summer"]) #Results: p-value = 0.08254
shapiro.test(dayActive$stateCountHour[dayActive$season=="Winter"]) #Results: p-value = 0.1597

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime active state
t.test(stateCountHour ~ season, data = dayActive, var.equal = TRUE) #Results: p-value = 

# Calculate summer mean and standard deviation of daytime absolute duration of active state
dayActiveSUm <- mean(dayActive$stateCountHour[dayActive$season == "Summer"])
dayActiveSUsd <- sd(dayActive$stateCountHour[dayActive$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of active state
dayActiveWIm <- mean(dayActive$stateCountHour[dayActive$season == "Winter"])
dayActiveWIsd <- sd(dayActive$stateCountHour[dayActive$season == "Winter"])

## Test for differences in resting state by season

# Test for normality
shapiro.test(dayRest$stateCountHour[dayRest$season=="Summer"]) #Results: p-value = 0.2386
shapiro.test(dayRest$stateCountHour[dayRest$season=="Winter"]) #Results: p-value =  0.1386

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime resting state
t.test(stateCountHour ~ season, data = dayRest, var.equal = TRUE) #Results: p-value = 3.61e-07

# Calculate summer mean and standard deviation of daytime absolute duration of resting state
dayRestSUm <- mean(dayRest$stateCountHour[dayRest$season == "Summer"])
dayRestSUsd <- sd(dayRest$stateCountHour[dayRest$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of resting state
dayRestWIm <- mean(dayRest$stateCountHour[dayRest$season == "Winter"])
dayRestWIsd <- sd(dayRest$stateCountHour[dayRest$season == "Winter"])
```

#### Altnerative more elegant test for seasonal differences in activity levels
Is there an elegant way to compare both seasons concurrently?



```{r}

```


### Q2b: Is there a seasonal difference in daytime absolute duration by degree of active state (i.e. low and high activity)?

#### Test for seasonal differences in daytime level of activity
When the active state is analyzed by degree (i.e. low activity and high activity), these data suggest caracaras spend more time in high activity during winter than in summer (summer 44.1 ± 26.1 min, winter 99.0 ± 45.2 min [mean ± SD]; Two Sample t-test p<0.01). There is no seasonal difference in daily time spent in low activity (summer 267 ± 2.0 min, winter 230 ± 1.6 min (mean ± SD); Two Sample t-test p=0.42). n=12 per season.


```{r lowDurdiff, warning=FALSE}
# Daytime state 3 (low activity)

# Create dataframe that includes only daytime total duration of state 3 per individual
state3day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="3") %>%
  ungroup

# Test for normality
shapiro.test(state3day$stateCountMin[state3day$season=="Summer"]) #Results: p-value = 0.0476
shapiro.test(state3day$stateCountMin[state3day$season=="Winter"]) #Results: p-value = 0.2116

# Test for equal variance
var.test(stateCountMin ~ season, data = state3day)

# Test for seasonal differences in daytime state 3 (low activity)
t.test(stateCountMin ~ season, data = state3day, var.equal = TRUE) #Results: p-value = 0.4173
wilcox.test(stateCountHour ~ season, data = state3day, var.equal = TRUE) #Results: W = 86, p-value = 0.4428


# Calculate summer mean and standard deviation of daytime absolute duration of state 3 (low activity)
mean(state3day$stateCountMin[state3day$season == "Summer"])
sd(state3day$stateCountMin[state3day$season == "Summer"])

# Daytime State 4 (high activity)

# Create dataframe that includes only daytime total duration of state 4 per individual
state4day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="4") %>%
  ungroup

# Test for normality
shapiro.test(state4day$stateCountMin[state4day$season=="Summer"]) #Results: p-value = 0.2107
shapiro.test(state4day$stateCountMin[state4day$season=="Winter"]) #Results: p-value = 0.2817

# Test for equal variance
var.test(stateCountMin ~ season, data = state4day)

# Test for seasonal differences in daytime state 4 (high activity)
t.test(stateCountMin ~ season, data = state4day, var.equal = TRUE) #Results: p-value = 0.001439
wilcox.test(stateCountHour ~ season, data = state4day, var.equal = TRUE) #Results: p-value = 0.001433

# Calculate summer mean and standard deviation of daytime absolute duration of state 4 (high activity)
mean(state4day$stateCountMin[state4day$season == "Winter"])
sd(state4day$stateCountMin[state4day$season == "Winter"])

```

#### Figure 2: Seasonal differences in daytime activity

```{r highDurdiff, warning=FALSE}
# Plot daytime absolute state durations
PdayDur34 <- stateSummaryIND2period %>%
  group_by(ID,season,dayNight) %>% 
  filter(dayNight == "day",
         state_classif == "3" | state_classif == "4") %>% #Alternative filter code: state_classif %in% c(3,4)
  ggplot() +
  geom_boxplot(aes(x=state_classif,y=stateCountMin, color = season)) +
  scale_color_discrete(name = "Season") +
  # scale_y_continuous(breaks = seq(0, 280, by = 10)) +
  scale_x_discrete(labels = c("Low Activity","High Activity")) +
  labs(x="State",
       y = "Duration (min)",
       title = "Seasonal daytime active state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PdayDur34
# Save a file at 300 ppi
# ggsave(PdayDur34, file="Seasonal daytime absolute state durations for states 3 and 4.png",width=12, height=8, dpi=300)

```



#### Plot of seasonal daytime absolute duration of active state by solar hour
Maybe use this one. This plots rest and active by solar hour. During summer, many resources are available across time. Whereas during winter, resources are spatiotemporally fixed.


```{r stateHr, warning=FALSE}

stateBout <- data_states %>% 
  group_by(season,ID) %>% 
  arrange(dttz) %>%
  mutate(boutNum = cumsum(replace_na(lag(state_classif) != state_classif, 1))) %>%
  ungroup %>% 
  group_by(season,ID,boutNum) %>% 
  mutate(boutLengthSec = n()) %>% #bout length is in seconds
  ungroup
stateBout$state_classif <- as.factor(stateBout$state_classif)
stateBout$state <- ifelse(stateBout$state_classif==1|stateBout$state_classif==2,"rest","active")
stateBout$hr <- hour(stateBout$dttz)
stateBout$hr <- as.factor(stateBout$hr)

# Create SolarMidnight based hourly bins
stateBout$solarMidnight <- hms::as.hms((stateBout$solarnoon- dhours(12)),tz = tzOffset)
stateBout$time <- hms::as.hms(stateBout$dttz,tz = tzOffset)
stateBout$timeBin <- floor(as.numeric(difftime(stateBout$time, stateBout$solarMidnight,units = "hours")))
stateBout$timeBin <- ifelse(stateBout$timeBin < 0,stateBout$timeBin+24,stateBout$timeBin)
stateBout$timeBin <- as.factor(stateBout$timeBin)

# Calculate bout length
stateBoutSummary <- stateBout %>%
  group_by(season,ID,boutNum,state_classif,dayNight,timeBin,state) %>%
  summarize(boutLengthSec=first(boutLengthSec)) %>%
  ungroup
stateBoutSummary

# Plot summer daytime absolute state duration by solar hour
pd <- position_dodge(0.1) # move them .05 to the left and right
PcountdayhrAct <- stateBout %>% 
  group_by(ID,dayNight,timeBin,season,state) %>%
  summarize(stateCount=n()/60) %>% #Calculates duration (minutes)
  filter(dayNight=="day",
         state=="active") %>%
  group_by(season,timeBin) %>% 
  summarize(mDur=mean(stateCount),
            seDur=std.error(stateCount)) %>% 
  ggplot() +
  geom_errorbar(aes(x=timeBin,ymin=mDur-seDur, ymax=mDur+seDur), width=.1,position=pd) +
  geom_point(aes(x=timeBin,y=mDur,colour=season),position=pd) +
  labs(x="Solar Hour of Day",
       y = "Mean Duration (min)",
       title = "Summer daytime mean state duration by solar hour (n=12)") + 
  scale_x_discrete(limits=0:24) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PcountdayhrAct

# Save a file at 300 ppi
# ggsave(PcountdayhrAct, file="Seasonal mean state durations by solar hour.png",width=12, height=8, dpi=300)
```



### Q3: Does daily distance traveled differ seasonally?
Calculate daily distance traveled by season. Step length might capture error because of 2-min duty cycle. Can subsample again so we're not affected by accuracy of location. Once I've calculated daily travel distance, I can compare to results of seasonal activity levels. 



```{r GPSstates, warning=FALSE}
# See Analyze TWLoggerGPS script
load("GPS_states.RData")



# Calculate total daytime distance traveled

distSum <- GPS_states %>% 
  group_by(season,ID) %>%
  summarize(distSum = sum(dist,na.rm = TRUE))

# Test for seasonal difference in total distance traveled
shapiro.test(distSum$distSum[distSum$season=="Summer"])
shapiro.test(distSum$distSum[distSum$season=="Winter"])
var.test(distSum ~ season, data = distSum)
t.test(distSum ~ season, data = distSum, var.equal = TRUE)

# Calculate total distance traveled SD
sd(distSum$distSum[distSum$season=="Summer"])
sd(distSum$distSum[distSum$season=="Winter"])


# Validate state classifications using distance traveled by state bout? Or mean distance traveled per 1 Hz by state?
# Calculate mean dist traveled by state
# Calculate mean daytime distance traveled by state
# Test for seasonal difference in daytime distance traveled by state

  
```


### Discussion

```{r}

```
