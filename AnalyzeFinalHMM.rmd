---
title: "Analyze Final HMM"
author: "Katie Harrington"
date: "April 19, 2019"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
     collapsed: false
     smooth_scroll: false
    df_print: paged
---
##

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Get Started

## Set up environment
This loads libraries, sets working directory, and creates local time zone offset.

```{r echo=FALSE,warnings=FALSE}
library(tidyverse)
library(dplyr)
library(maptools) # to calculate solarpos
library(stringr)
library(lubridate)
library(adehabitatLT)
library(geosphere)
library(ggpubr)
library(sp)
library(rgdal)
library(tibble)
library("rnaturalearth")
library("rnaturalearthdata")
library("sf")
library("ggspatial")
library(marmap)
library(mapdata)
library(metR)
library(RcppRoll)

setwd("~/Projects/R/TWlogger")
tzOffset <-"Etc/GMT+3"
```

# Prep Data
This imports and combines data frames to produce data_states.Rdata. Only need to run this section once, unless needing to recreate data_states.Rdata.

## Import HMM data
This imports data with HMM states and runs SunriseSunsetTimes.r.



```{r echo=FALSE}

# Load R workspace
load("~/Projects/R/TWlogger/data_with_states.RData")
# Combine list into one dataframe
data <-bind_rows(data_with_states)
rm(data_with_states)
# Create Spatial Points
data$long <- -60.09
data$lat <- -51.37

# Check dttz 
attr(data$dttz, "tzone") #Check tz
attr(data$dttz, "tzone") <- tzOffset

data$date <- as.Date(data$dttz, tz = tzOffset)

# Run the sunrise sunset script
source('SunriseSunsetTimes.r')
# Check for NAs
sapply(data, function(x) sum(is.na(x)))
# Determine Season (calculated from 2018 solstices and equinoxes)
data$yday <- yday(data$dttz)
data$season <- rep('NA')
#data[which(data$yday > 79 & data$yday <= 173),]$season <- 'Fall'
data[which(data$yday > 173 & data$yday <= 265),]$season <- 'Winter'
#data[which(data$yday > 265 & data$yday < 355),]$season <- 'Spring'
data[which(data$yday >= 355 | data$yday <= 79),]$season <- 'Summer'
data$season <- as.factor(data$season)
unique(data$season)

# Rename data
data_states <-data
rm(data)
```

## Import Raw Acc, combine with HMM states data, and calculate ODBA
This creates one file that includes states and raw acc. Saves as data_states.Rdata.


```{r echo=FALSE,warnings=FALSE}
# load Final Metrics from AnalyzeFinalAccV1
load("~/Projects/R/TWlogger/FinalMetrics.RData")
# Add acc data to stateData
data_states <- left_join(data_states,dplyr::select(data,ID,dttz,Ax,Ay,Az), by = c("ID","dttz"))
rm(data)
# Consolidate astronomical periods two periods (day and night)
data_states <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup
# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

# Create SolarMidnight based hourly bins
data_states$solarMidnight <- hms::as.hms((data_states$solarnoon- dhours(12)),tz = tzOffset)
data_states$time <- hms::as.hms(data_states$dttz,tz = tzOffset)
data_states$timeBin <- floor(as.numeric(difftime(data_states$time, data_states$solarMidnight,units = "hours")))
data_states$timeBin <- ifelse(data_states$timeBin < 0,data_states$timeBin+24,data_states$timeBin)
data_states$hr <- hour(data_states$dttz)
data_states$night <- NULL

# Recalculate ODBA (ms-2)
# Calculate static (running mean)
windowSize=11 
data_states <- data_states %>% 
  arrange(ID,dttz) %>% 
  group_by(ID) %>% 
  mutate(static_Ax=roll_mean(Ax,windowSize,fill=NA),
         static_Ay=roll_mean(Ay,windowSize,fill=NA),
         static_Az=roll_mean(Az,windowSize,fill=NA)) %>%
  ungroup

# Replace the NA's at the beginning with the first good value
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>%
  mutate(naUp = ifelse(row_number()<=(windowSize-1)/2+1,1,0),
         naDown = ifelse(row_number() > n() - ((windowSize-1)/2+1),1,0)) %>%# View
  ungroup %>% 
  group_by(ID,naUp) %>% 
  mutate(static_Ax = ifelse(naUp == 1,last(static_Ax),static_Ax),
         static_Ay = ifelse(naUp == 1,last(static_Ay),static_Ay),
         static_Az = ifelse(naUp == 1,last(static_Az),static_Az)) %>% 
  ungroup %>% 
  group_by(ID,naDown) %>% 
  mutate(static_Ax = ifelse(naDown == 1,first(static_Ax),static_Ax),
         static_Ay = ifelse(naDown == 1,first(static_Ay),static_Ay),
         static_Az = ifelse(naDown == 1,first(static_Az),static_Az)) %>% 
  ungroup
data_states$naUp <- NULL
data_states$naDown <- NULL

# Calculate dynamic (raw-static) and ODBA (sum abs dynamic)
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>% 
  mutate(dyn_Ax=Ax-static_Ax,
         dyn_Ay=Ay-static_Ay,
         dyn_Az=Az-static_Az,
         ODBA=abs(dyn_Ax+dyn_Ay+dyn_Az)) %>% 
  ungroup #%>% View

data_states$ODBA <- data_states$ODBA
data_states$state <-ifelse(data_states$state_classif==1|data_states$state_classif==2,"Rest","Active")
data_states$yr <- year(data_states$dttz)
data_states$dawnT <- hour(data_states$dawn) + second(data_states$dawn)/60
data_states$duskT <- hour(data_states$dusk) + second(data_states$dusk)/60


# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

# save(data_states,file="data_states.RData")
```

# Analyze Data
Begin here to continue analysis below. This loads data_states.Rdata which contains ODBA values and state class identified by 4-state HMM.


```{r echo=FALSE,warnings=FALSE}
load("~/Projects/R/TWlogger/data_states.RData")

```

### Calculate state count and proportions by astronomical period (dawn, day, dusk, night).
This creates stateSummaryIND.


```{r warnings=FALSE}
# Calculate state count and proportions by 4 periods (dawn, day, dusk, night)
stateSummaryIND <- data_states %>% 
  group_by(season, ID, astronomical) %>% 
  mutate(periodLength = n()) %>% 
  ungroup %>% 
  group_by(season, ID, astronomical, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateProp = stateCount/periodLength) %>% 
  ungroup

# Change classes for plotting
stateSummaryIND$ID <- as.factor(stateSummaryIND$ID)
stateSummaryIND$astronomical <- as.factor(stateSummaryIND$astronomical)

# Create vectors to retain groupings for plots
stateSummaryIND$season_per_state <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,
                                          stateSummaryIND$state_classif,sep="_")
stateSummaryIND$season_period <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,sep="_")
```

### Calculate 4-state and 2-state counts and proportions by day and night.
This creates stateSummaryIND2period, stateSummaryIND2period2state, dayActive, and dayRest.

```{r warning=FALSE}
# 4-state, 2 period
# Create new dataframe that combines astronomical periods into day and night and calculates 4-state counts and proportions
stateSummaryIND2period <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight) %>% 
  mutate(periodLength = n()) %>%
  ungroup %>% 
  group_by(season, ID, dayNight, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateCountMin = stateCount/60,
         stateCountHour = stateCount/60/60,
         stateProp = stateCount/periodLength) %>% 
  ungroup

# Create vectors to retain groupings for plots
stateSummaryIND2period$ID <- as.factor(stateSummaryIND2period$ID)
stateSummaryIND2period$dayNight <- as.factor(stateSummaryIND2period$dayNight)
stateSummaryIND2period$season_per_state <- paste(stateSummaryIND2period$season,
                                          stateSummaryIND2period$dayNight,
                                          stateSummaryIND2period$state_classif,sep="_")
stateSummaryIND2period$season_period <- paste(stateSummaryIND2period$season,
                                       stateSummaryIND2period$dayNight,sep="_")
stateSummaryIND2period$state_classif <- as.factor(stateSummaryIND2period$state_classif)

# 2-state, 2 period
# Create new dataframe that combines active and rest states and calculates 2-state count and proportions
stateSummaryIND2period2state <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif) %>%
  mutate(state = ifelse(state_classif %in% c("1","2"),"rest","active")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight,state,periodLength) %>% 
  summarize(stateCount2state = sum(stateCount)) %>% 
  mutate(stateCountMin = stateCount2state/60,
         stateCountHour = stateCount2state/60/60,
         stateProp = stateCount2state/periodLength) %>% 
  ungroup

# Create dataframe of only daytime active state
dayActive <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="active") 

# Create dataframe of only daytime resting state
dayRest <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="rest") 
```

### Justify nighttime exclusion from analysis.
These data suggest a diel pattern between seasons with over 95% of nighttime during both seasons spent in the resting state. This implies that the difference in overall ODBA totals in a 24-hr period are being represented in the daytime. 


```{r warning=FALSE}
# % Time spent resting during night
restPropSU <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight,state) %>% 
  summarize(stateProp = mean(stateProp))
```



```{r warning=FALSE}
# Plot nighttime absolute state durations
PnightDur <- stateSummaryIND2period2state %>% #View
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>% 
  ggplot() +
  geom_boxplot(aes(x = state, y = stateCountHour,color = season)) +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 24, by = 2)) +
  labs(x="State",
       y = "Duration (hr)",
       title = "Seasonal nighttime state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Plot nighttime state proportions
PnightProp <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>% 
  ggplot() +
  geom_boxplot(aes(x = state, y = stateProp, color = season)) +
  ylim(0,1) +
  labs(x="State",
       y = "Proportion (%)",
       title = "Seasonal nighttime state proportions") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Stack plots to compare full cycle
PnightDurProp <- ggarrange(PnightDur,PnightProp,nrow=2)
PnightDurProp
rm(PnightDur,PnightProp,PnightDurProp)

# Save a file at 300 ppi
# ggsave(PnightDurProp, file="Seasonal nighttime state absolute durations and proportions.png",width=8, height=8, dpi=300)
```

##Q1: Is there a seasonal difference in total daily ODBA?

### Calculate total daily ODBA (g) per ID
This creates sumODBA which contains total daily ODBA for all individuals across years. This also creates dataframes by season (sumODBASU and sumODBAWI).

```{r warning=FALSE}
# Calculate daily ODBA (g) totals per ID
sumODBA <- data_states %>% 
  group_by(yr,season,ID) %>%
  summarize(sumODBA = sum(ODBA/9.81,na.rm = TRUE)) # convert ODBA from ms-2 to g (divide by 9.81)

# Create dataframes of seasonal daily ODBA (g) totals
sumODBASU <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Summer") 

sumODBAWI <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Winter") 
```

### Confirm pooling seasons across years.
This tests for differences in total ODBA per year. If there is no interannual difference by seasons, this by default confirms there are no effects from tag versioning. There is no difference in total ODBA per season between years (summer p=0.83, winter p=0.11).

```{r warning=FALSE}
# Plot density distributions
dSU <- density(sumODBASU$sumODBA-mean(sumODBASU$sumODBA))
plot(dSU)
dWI <- density(sumODBAWI$sumODBA-mean(sumODBAWI$sumODBA))
plot(dWI)

# Test for normality
shapiro.test(sumODBASU$sumODBA)
shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ yr,data=sumODBASU) #Variance is equal
var.test(sumODBA ~ yr,data=sumODBAWI) #Variance is equal

# Test for differences within each season by year to confirm pooling
t.test(sumODBA ~ yr, data=sumODBASU,var.equal = TRUE)
t.test(sumODBA ~ yr, data=sumODBAWI,var.equal = TRUE)

rm(dSU,dWI)
```

### Test for seasonal differences in total daily ODBA (g)
Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).

```{r warning=FALSE}
# Test for normality
shapiro.test(sumODBASU$sumODBA)
shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ season,data=sumODBA) #Variance is equal

# Test for seasonal differences
test <- t.test(sumODBA ~ season,data=sumODBA,var.equal = TRUE)
test

sd(sumODBASU$sumODBA)
sd(sumODBAWI$sumODBA)
```


### Figure 1: Seasonal differences in daily ODBA totals by solar hour

```{r warning=FALSE}
# Meanline summer
meanlineSU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))
# Meanline winter
meanlineWI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))

# Calculate time of mean dawn and dusk and create dataframes to use for shading bins in total daily ODBA plot
shadeSU = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Summer"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Summer"])),23),
                     y1=c(0,0),
                     y2=c(800,800))
shadeWI = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Winter"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Winter"])),23),
                     y1=c(0,0),
                     y2=c(800,800))

# Summer total ODBA per solar hour
PodbaSum24SU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin,dayNight) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7) +
  geom_line(data=meanlineSU,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  ylim(0,800) +
  scale_x_continuous(breaks = seq(0,23, by = 1)) +
  labs(x="Solar Hour",
       y = NULL,
       title = "(b)") + 
  geom_rect(data=shadeSU, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PodbaSum24SU

# Winter total ODBA per solar hour
PodbaSum24WI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7)+
  geom_line(data=meanlineWI,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  ylim(0,800) +
  scale_x_continuous(breaks = seq(0,23, by = 1)) +
  labs(x=NULL,
       y = NULL,
       title = "(a)") + 
  geom_rect(data=shadeWI, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PodbaSum24WI

Podba24Seas <- ggarrange(PodbaSum24WI,PodbaSum24SU,nrow=2)
Podba24Seas <- annotate_figure(Podba24Seas,
               top = text_grob("Seasonal total ODBA by solar hour", color = "black", size = 14, just="right"),
               #bottom = text_grob("Figure 1. Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).", color = "black",hjust = 1, x = 1, size = 10)#,
               left = text_grob("Total ODBA (g)", color = "black", rot = 90)
)

Podba24Seas
rm(meanlineSU,meanlineWI,PodbaSum24SU,PodbaSum24WI)
# Save a file at 300 ppi
# ggsave(Podba24Seas, file="Seasonal total ODBA per solar hour_shaded.png",dpi=300)
```


## Q2a: Is there a seasonal difference in daytime absolute duration of the active state?

### Test for seasonal differences in daytime total activity
Pooling the active and resting states masked the seasonal differences in activity. There is no seasonal difference in total time spent in the active state (winter = 5.48 ± 2.18 hr, summer = 5.19 ± 2.38 hr [mean ± SD]; Two Sample t-test, p=0.75).

```{r warning=FALSE}
## Test for differences in daytime absolute duration of active state by season

# Test for normality
shapiro.test(dayActive$stateCountHour[dayActive$season=="Summer"]) #Results: p-value = 0.08254
shapiro.test(dayActive$stateCountHour[dayActive$season=="Winter"]) #Results: p-value = 0.1597

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime active state
t.test(stateCountHour ~ season, data = dayActive, var.equal = TRUE) #Results: p-value = 

# Calculate summer mean and standard deviation of daytime absolute duration of active state
dayActiveSUm <- mean(dayActive$stateCountHour[dayActive$season == "Summer"])
dayActiveSUsd <- sd(dayActive$stateCountHour[dayActive$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of active state
dayActiveWIm <- mean(dayActive$stateCountHour[dayActive$season == "Winter"])
dayActiveWIsd <- sd(dayActive$stateCountHour[dayActive$season == "Winter"])

## Test for differences in resting state by season

# Test for normality
shapiro.test(dayRest$stateCountHour[dayRest$season=="Summer"]) #Results: p-value = 0.2386
shapiro.test(dayRest$stateCountHour[dayRest$season=="Winter"]) #Results: p-value =  0.1386

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime resting state
t.test(stateCountHour ~ season, data = dayRest, var.equal = TRUE) #Results: p-value = 3.61e-07

# Calculate summer mean and standard deviation of daytime absolute duration of resting state
dayRestSUm <- mean(dayRest$stateCountHour[dayRest$season == "Summer"])
dayRestSUsd <- sd(dayRest$stateCountHour[dayRest$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of resting state
dayRestWIm <- mean(dayRest$stateCountHour[dayRest$season == "Winter"])
dayRestWIsd <- sd(dayRest$stateCountHour[dayRest$season == "Winter"])
```

## Q2b: Is there a seasonal difference in daytime absolute duration by degree of active state (i.e. low and high activity)?

### Test for seasonal differences in daytime level of activity
When the active state is analyzed by degree (i.e. low activity and high activity), these data suggest caracaras spend more time in high activity during winter than in summer (summer 44.1 ± 26.1 min, winter 99.0 ± 45.2 min [mean ± SD]; Two Sample t-test p<0.01). There is no seasonal difference in daily time spent in low activity (summer 267 ± 2.0 min, winter 230 ± 1.6 min (mean ± SD); Two Sample t-test p=0.42). n=12 per season.


```{r warning=FALSE}
# Daytime state 3 (low activity)

# Create dataframe that includes only daytime total duration of state 3 per individual
state3day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="3") %>%
  ungroup

# Test for normality
shapiro.test(state3day$stateCountMin[state3day$season=="Summer"]) #Results: p-value = 0.0476
shapiro.test(state3day$stateCountMin[state3day$season=="Winter"]) #Results: p-value = 0.2116

# Test for equal variance
var.test(stateCountMin ~ season, data = state3day)

# Test for seasonal differences in daytime state 3 (low activity)
t.test(stateCountMin ~ season, data = state3day, var.equal = TRUE) #Results: p-value = 0.4173
wilcox.test(stateCountHour ~ season, data = state3day, var.equal = TRUE) #Results: W = 86, p-value = 0.4428


# Calculate summer mean and standard deviation of daytime absolute duration of state 3 (low activity)
mean(state3day$stateCountMin[state3day$season == "Summer"])
sd(state3day$stateCountMin[state3day$season == "Summer"])

# Daytime State 4 (high activity)

# Create dataframe that includes only daytime total duration of state 4 per individual
state4day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="4") %>%
  ungroup

# Test for normality
shapiro.test(state4day$stateCountMin[state4day$season=="Summer"]) #Results: p-value = 0.2107
shapiro.test(state4day$stateCountMin[state4day$season=="Winter"]) #Results: p-value = 0.2817

# Test for equal variance
var.test(stateCountMin ~ season, data = state4day)

# Test for seasonal differences in daytime state 4 (high activity)
t.test(stateCountMin ~ season, data = state4day, var.equal = TRUE) #Results: p-value = 0.001439
wilcox.test(stateCountHour ~ season, data = state4day, var.equal = TRUE) #Results: p-value = 0.001433

# Calculate summer mean and standard deviation of daytime absolute duration of state 4 (high activity)
mean(state4day$stateCountMin[state4day$season == "Winter"])
sd(state4day$stateCountMin[state4day$season == "Winter"])

```

### Figure 2: Seasonal differences in total daytime level in both high activity and low activity

```{r warning=FALSE}
# Plot daytime absolute state durations
PdayDur34 <- stateSummaryIND2period %>%
  group_by(ID,season,dayNight) %>% 
  filter(dayNight == "day",
         state_classif == "3" | state_classif == "4") %>% #Alternative filter code: state_classif %in% c(3,4)
  ggplot() +
  geom_boxplot(aes(x=state_classif,y=stateCountMin, color = season)) +
  scale_color_discrete(name = "Season") +
  # scale_y_continuous(breaks = seq(0, 280, by = 10)) +
  scale_x_discrete(labels = c("Low Activity","High Activity")) +
  labs(x="State",
       y = "Duration (min)",
       title = "Seasonal daytime active state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PdayDur34
# Save a file at 300 ppi
# ggsave(PdayDur34, file="Seasonal daytime absolute state durations for states 3 and 4.png",width=12, height=8, dpi=300)

```

# Q3: How does daily distance traveled differ seasonally?
Calculate daily distance traveled by season. Step length might capture error because of 2-min duty cycle. Can subsample again so we're not affected by accuracy of location. Once I've calculated daily travel distance, I can compare to results of seasonal activity levels. 



```{r}
# See Analyze TWLoggerGPS script
load("~/Projects/R/TWlogger/GPS_states.RData")



# Calculate total daytime distance traveled

distSum <- GPS_states %>% 
  group_by(season,ID) %>%
  summarize(distSum = sum(dist,na.rm = TRUE))

# Test for seasonal difference in total distance traveled
shapiro.test(distSum$distSum[distSum$season=="Summer"])
shapiro.test(distSum$distSum[distSum$season=="Winter"])
var.test(distSum ~ season, data = distSum)
t.test(distSum ~ season, data = distSum, var.equal = TRUE)

# Calculate total distance traveled SD
sd(distSum$distSum[distSum$season=="Summer"])
sd(distSum$distSum[distSum$season=="Winter"])


# Validate state classifications using distance traveled by state bout? Or mean distance traveled per 1 Hz by state?
# Calculate mean dist traveled by state
# Calculate mean daytime distance traveled by state
# Test for seasonal difference in daytime distance traveled by state

  
```


# Discussion

```{r}

```


# Boneyard

## Unused state analyses and plots

### Plot of seasonal daytime absolute duration of active state by solar hour
Maybe use this one. This plots rest and active by solar hour. During summer, many resources are available across time. Whereas during winter, resources are spatiotemporally fixed.


```{r warning=FALSE}
# KJH: Change this from boxplot to mean point with error bars.

# Plot summer absolute state duration by solar hour
PcountSUdhr <- stateBout %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(stateCount=n()/60) %>%
  filter(season=="Summer",
         dayNight=="day") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = stateCount, 
                   color = state)) +
  labs(x="Solar Hour of Day",
       y = "Duration (min)",
       title = "Summer absolute state duration by solar hour (n=12)") + 
  scale_x_discrete(limits=0:24) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PcountSUdhr

# Plot winter absolute state duration by solar hour
PcountWIdhr <- stateBout %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(stateCount=n()/60) %>%
  filter(season=="Winter",
         dayNight=="day") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = stateCount, 
                   color = state)) +
  labs(x="Solar Hour of Day",
       y = "Duration (min)",
       title = "Winter absolute state duration by solar hour (n=12)") + 
  scale_x_discrete(limits=0:24) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PcountWIdhr

PcountSeasdhr <- ggarrange(PcountSUdhr,PcountWIdhr,nrow=2)
PcountSeasdhr

# Save a file at 300 ppi
# ggsave(PcountSeasdhr, file="Seasonal absolute state durations by solar hour.png",width=12, height=8, dpi=300)
```


## Q2c: Is there a seasonal difference in mean daytime bout lengths? Nighttime bout lengths? Are winter nights more fitful?
This calculates daytime state bout length (seconds) for the pooled active state and again for the unpooled active states (low and high activity). This creates stateBout, stateBoutSummary, state3boutDayIndMeans (seconds), and state4boutDayIndMeans. 


```{r warning=FALSE}
# Need use test for samples of unequal lengths (summer days are longer)
# Results: Mean bout lengths have a exponential/Poisson/Gamma distribution? Cannot use Shapiro test for normality because n>10000.

stateBout <- data_states %>% 
  group_by(season,ID) %>% 
  arrange(dttz) %>%
  mutate(boutNum = cumsum(replace_na(lag(state_classif) != state_classif, 1))) %>%
  ungroup %>% 
  group_by(season,ID,boutNum) %>% 
  mutate(boutLengthSec = n()) %>% #bout length is in seconds
  ungroup
stateBout$state_classif <- as.factor(stateBout$state_classif)
stateBout$state <- ifelse(stateBout$state_classif==1|stateBout$state_classif==2,"rest","active")
stateBout$hr <- hour(stateBout$dttz)
stateBout$hr <- as.factor(stateBout$hr)

# Create SolarMidnight based hourly bins
stateBout$solarMidnight <- hms::as.hms((stateBout$solarnoon- dhours(12)),tz = tzOffset)
stateBout$time <- hms::as.hms(stateBout$dttz,tz = tzOffset)
stateBout$timeBin <- floor(as.numeric(difftime(stateBout$time, stateBout$solarMidnight,units = "hours")))
stateBout$timeBin <- ifelse(stateBout$timeBin < 0,stateBout$timeBin+24,stateBout$timeBin)
stateBout$timeBin <- as.factor(stateBout$timeBin)

# Calculate bout length
stateBoutSummary <- stateBout %>%
  group_by(season,ID,boutNum,state_classif,dayNight,timeBin,state) %>%
  summarize(boutLengthSec=first(boutLengthSec)) %>%
  ungroup
stateBoutSummary
rm(stateBout)

# Determine probability distributions of bout lengths

# Test for normality of summer daytime state 3 mean bout lengths (seconds)
hist(stateBoutSummary$boutLengthSec[stateBoutSummary$season=="Summer" & 
                                           stateBoutSummary$dayNight=="day" & 
                                           stateBoutSummary$state_classif=="3"]) 
# Test for normality of summer daytime state 4 mean bout lengths (seconds)
hist(stateBoutSummary$boutLengthSec[stateBoutSummary$season=="Summer" & 
                                           stateBoutSummary$dayNight=="day" & 
                                           stateBoutSummary$state_classif=="4"])

# Calculate mean state bout for state 3 per indidivual
state3boutDayIndMeans <- stateBoutSummary %>% 
  group_by(season,ID,dayNight,state_classif,boutLengthSec) %>%
  filter(dayNight=="day",
         state_classif=="3") %>%
  ungroup %>% 
  group_by(ID,season) %>%
  summarize(meanBoutLengthSec=mean(boutLengthSec))

# Calculate mean state bout for state 4 per indidivual
state4boutDayIndMeans <- stateBoutSummary %>% 
  group_by(season,ID,dayNight,state_classif,boutLengthSec) %>%
  filter(dayNight=="day",
         state_classif=="4") %>%
  ungroup %>% 
  group_by(ID,season) %>%
  summarize(meanBoutLengthSec=mean(boutLengthSec))

shapiro.test(state4boutDayIndMeans$meanBoutLengthSec)
hist(state4boutDayIndMeans$meanBoutLengthSec)
```

###Plot of seasonal daytime mean bout lengths per state
This plots seasonal mean state bouts (active and rest) by solar hour. 
KJH: Add plotline of astronomical sunrise and sunset. Look at FrontiersMovementAnalysis.

```{r warning=FALSE}
# Plot summer mean state bouts (active and rest) by solar hour. 
PboutSU <- stateBoutSummary %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(mboutLengthMin=(mean(boutLengthSec)/60)) %>%
  ungroup %>% # Do I need to ungroup and regroup?
  group_by(season,ID,dayNight,timeBin,state,mboutLengthMin) %>%
  filter(season=="Summer") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = mboutLengthMin, 
                   color = state)) +
  scale_x_discrete(breaks = seq(0, 24, by = 1)) +
  labs(x="Hour of Day",
       y = "Bout Length (min)",
       title = "Summer mean activity bout by solar hour") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PboutSU

# Plot winter mean state bouts (active and rest) by solar hour. 
PboutWI <- stateBoutSummary %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(mboutLengthMin=(mean(boutLengthSec)/60)) %>%
  ungroup %>% # Do I need to ungroup and regroup?
  group_by(season,ID,dayNight,timeBin,state,mboutLengthMin) %>%
  filter(season=="Winter") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = mboutLengthMin, 
                   color = state)) +
  labs(x="Hour of Day",
       y = "Bout Length (min)",
       title = "Winter mean activity bout by solar hour") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PboutWI

PboutSeas <- ggarrange(PboutSU,PboutWI,nrow=2)
PboutSeas

# Plot seasonal daytime mean state bouts
PboutDay <-stateBoutSummary %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(mboutLengthMin=(mean(boutLengthSec)/60)) %>%
  ungroup %>% # Do I need to ungroup and regroup?
  group_by(season,ID,dayNight,timeBin,state,mboutLengthMin) %>%
  filter(dayNight=="day",
         state=="active") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = mboutLengthMin, color = season)) +
  labs(x="Hour of Day",
       y = "Bout Length (min)",
       title = "Seasonal daytime mean active state by solar hour") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PboutDay

```

### Plot distribution of daytime state bouts (min) by state and season

```{r warning=FALSE}
# Plot distribution of daytime state bouts by austral season
distboutLengthDay <- stateBoutSummary %>% 
  group_by(season,state_classif) %>%
  filter(dayNight=="day") %>% 
  ggplot()+
  geom_histogram(aes(boutLength))+
  labs(x="State Bouts (min)",
       y = "Frequency",
       title = "Distribution of daytime state bouts by austral season") + 
  facet_grid(season~state_classif)
distboutLengthDay
ggsave(distboutLengthDay, file="Distribution of daytime state bouts by austral season.png",width=12, height=6, dpi=300)

# Plot distribution of nighttime state bouts by austral season
distboutLengthNight <- stateBoutSummary %>% 
  group_by(season,state_classif) %>%
  filter(dayNight=="night") %>% 
  ggplot()+
  geom_histogram(aes(boutLength))+
  labs(x="State Bouts (min)",
       y = "Frequency",
       title = "Distribution of nighttime state bouts by austral season") + 
  facet_grid(season~state_classif)
distboutLengthNight
ggsave(distboutLengthNight, file="Distribution of nighttime state bouts by austral season.png",width=12, height=6, dpi=300)

# Plot distribution of daytime state 4 bouts per bird by austral season
distboutLengthDay4 <- stateBoutSummary %>% 
  group_by(ID,season,state_classif) %>%
  filter(dayNight=="day",
         state_classif=="4") %>% 
  ggplot()+
  geom_histogram(aes(boutLength))+
  labs(x="State Bouts (min)",
       y = "Frequency",
       title = "Distribution of daytime state 4 bouts per bird by austral season") + 
  facet_grid(season~ID)
distboutLengthDay4
ggsave(distboutLengthDay4, file="Distribution of daytime state 4 bouts per bird by austral season.png",width=12, height=6, dpi=300)

# Plot distribution of daytime state 3 bouts per bird by austral season
distboutLengthDay3 <- stateBoutSummary %>% 
  group_by(ID,season,state_classif) %>%
  filter(dayNight=="day",
         state_classif=="3") %>% 
  # ggplot() + 
  #    geom_histogram(aes(boutLength)) + 
  #    facet_wrap(~season, scales = 'free', nrow = 2, strip.position = 'right')
  ggplot()+
  geom_histogram(aes(boutLength))+
  labs(x="State Bouts (min)",
       y = "Frequency",
       title = "Distribution of daytime state 3 bouts per bird by austral season") +
  facet_grid(season~ID)
distboutLengthDay3
ggsave(distboutLengthDay3, file="Distribution of daytime state 3 bouts per bird by austral season.png",width=12, height=6, dpi=300)

rm(distboutLengthDay,distboutLengthNight,distboutLengthDay3,distboutLengthDay4)

# State 3 attempt at histogram by individual
# scales = "free_x" not working
PhistState3 <- data_states %>%
  # group_by(ID,season,dayNight) %>% 
  filter(season=="Winter",
         dayNight == "day",
         state_classif =="3") %>%
  ggplot() +
  geom_bar(aes(x =state_classif,color = ID),fill="white",position="dodge") +
  # geom_vline()
  labs(x="State 3",
       y = "Frequency",
       title = "Austral winter daytime frequency of state 3") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PhistState3

# State 4 attempt at histogram by individual
PhistState4 <- data_states %>%
  # group_by(ID,season,dayNight) %>% 
  filter(season=="Winter",
         dayNight == "day",
         state_classif =="4") %>%
  ggplot() +
  geom_bar(aes(x =state_classif,color = ID),fill="white",position="dodge") +
  # geom_vline()
  labs(x="State 4",
       y = "Frequency",
       title = "Austral winter daytime frequency of state 4") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PhistState4

# Stack plots to compare full cycle
PhistState34 <- ggarrange(PhistState3,PhistState4,nrow=2)
# Save a file at 300 ppi
ggsave(PhistState34, file="Winter daytime frequencies of state 3 and state 4.png",width=8, height=8, dpi=300)
rm(PhistState3,PhistState4)
```

### Test to compare state proportions and absolute durations per period

```{r warning=FALSE}
# Test for difference in state duration between summer and winter day
# This subsets by day/night and filters for season, day, and state 4.
seasdiffdur1 <- stateSummaryIND2period %>% 
  subset(.,select = c(season,dayNight,state_classif,stateCountHour)) %>%
  filter(dayNight == "day",
         season == "Winter",
         state_classif == "4")
  # spread(season,stateCountHour)
seasdiffdur1$stateCountHourWI <- seasdiffdur1$stateCountHour
seasdiffdur1$stateCountHour <- NULL
seasdiffdur2 <- stateSummaryIND2period %>% 
  subset(.,select = c(season,dayNight,state_classif,stateCountHour)) %>%
  filter(dayNight == "day",
         season == "Summer",
         state_classif == "4")
  # spread(season,stateCountHour) 
seasdiffdur2$stateCountHourSU <- seasdiffdur2$stateCountHour
seasdiffdur2$stateCountHour <- NULL
shapiro.test(seasdiffdur1$stateCountHourWI)
shapiro.test(seasdiffdur2$stateCountHourSU)
test <- stats::t.test(seasdiffdur1$stateCountHourWI,seasdiffdur2$stateCountHourSU)
test

seasdiffdurState4 <- cbind(seasdiffdur1$stateCountHourWI,seasdiffdur2$stateCountHourSU)
colnames(seasdiffdurState4) <- c("stateCountHourWI", "stateCountHourSU")
# write_csv(as.data.frame(seasdiffdurState4),file.path(getwd(),"state4duration.csv"))
```

### Plots raw data distribution of states by season
*Irrelevant because variable of interest is ODBA daily sum not raw values. 
*This shows raw ODBA (1-Hz) is left skewed.
```{r warning=FALSE}
# Plot distribution of ODBA values
dist <- data_states %>% 
  ggplot()+
  geom_histogram(aes(ODBA))
dist

# Plot distribution of ODBA values by state (ALL INDIVIDUALS COMBINED)
dist_state <- data_states %>% 
  group_by(season,state_classif) %>%
  ggplot()+
  geom_histogram(aes(ODBA))+
  facet_grid(season~state_classif)
dist_state
ggsave(dist_state, file="ODBA distributions grouped by season and state.png",width=12, height=6, dpi=300)

data_states$yr <- year(data_states$dttz)
data_states$yr <- as.factor(data_states$yr)
data_states$ID <- as.factor(data_states$ID)
data_states$state_classif <- as.factor(data_states$state_classif)

```


### Calculate mean and SD for total ODBA over 24 hours.
*KJH: This needs work.
```{r warning=FALSE}
# Mean and SD of summer total ODBA per solar hour

# Mean and SD of winter total ODBA per solar hour
sumODBAWImean <- mean(sumODBAWI$sumODBA)
sumODBAWIsd <- sd(sumODBAWI$sumODBA)
summarySumODBA <- sumODBA %>% 
  group_by(season) %>% 
  summarize(mean(sumODBA),
            sd(sumODBA))
```

### Plot of seasonal mean oDBA per solar hour
This could be used to see if there are daily patterns in actity levels by hour across individuals.

```{r warning=FALSE}
# KJH: This needs work.

# Plot summer mean ODBA by solar hour
PodbaMeanSU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID,timeBin) %>%
  summarize(odbaGMean = mean(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGMean, group=ID,color=ID)) +
  labs(x="Solar Hour",
       y = "Mean ODBA (g)",
       title = "Austral summer mean ODBA per solar hour") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PodbaMeanSU

# Plot winter mean ODBA by solar hour
PodbaMeanWI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGMean = mean(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGMean, group=ID),alpha=0.7) +
  labs(x="Solar Hour",
       y = "Mean ODBA (g)",
       title = "Austral winter mean ODBA per solar hour") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PodbaMeanWi

PodbaMeanSeas <- ggarrange(PodbaMeanSU,PodbaMeanWI,nrow=2)
PodbaMeanSeas

# Save a file at 300 ppi
# ggsave(PodbaMeanSeas, file="Seasonal mean ODBA per solar hour_black.png",width=12, height=6, dpi=300)
```

### Plot of seasonal daytime absolute duration of active state
Not including plot in thesis. Will include verbal results.
```{r warning=FALSE}
# Plot daytime absolute state durations
PdayDur <- stateSummaryIND2period2state %>%
  group_by(ID,season,dayNight) %>% 
  filter(dayNight == "day") %>%
  ggplot() +
  geom_boxplot(aes(x=state,y=stateCountHour, color = season)) +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 24, by = 2)) +
  labs(x="State",
       y = "Duration (hr)",
       title = "Seasonal daytime state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PdayDur
# Save a file at 300 ppi
# ggsave(PdayDur, file="Seasonal daytime absolute state durations of active and rest.png",width=12, height=8, dpi=300)
```


### Plot seasonal nighttime activity absolute duration by solar hour
*Excluded nighttime period from analysis. 
```{r warning=FALSE}
# Plot summer nighttime activity absolute duration by hour
PcountSUnhr <- stateBout %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(stateCount=n()/60) %>%
  filter(season=="Summer",
         dayNight=="night") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = stateCount, 
                   color = state)) +
  labs(x="Solar Hour of Day",
       y = "Duration (min)",
       title = "Summer nighttime activity absolute duration by hour (n=12)") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PcountSUnhr

# Plot winter nighttime activity absolute duration by hour
PcountWInhr <- stateBout %>% 
  group_by(season,ID,dayNight,timeBin,state) %>%
  summarize(stateCount=n()/60) %>%
  filter(season=="Winter",
         dayNight=="night") %>%
  ggplot() +
  geom_boxplot(aes(x = timeBin, y = stateCount, 
                   color = state)) +
  labs(x="Solar Hour of Day",
       y = "Duration (min)",
       title = "Winter nighttime activity absolute duration by hour (n=12)") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
# PcountWInhr

PcountSeasnhr <- ggarrange(PcountSUnhr,PcountWInhr,nrow=2)
PcountSeasnhr
```

