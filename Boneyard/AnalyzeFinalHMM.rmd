---
title: "Striated Caracara"
subtitle: "ODBA and Activity Budget Analysis"
author: "Katie Harrington"
date: "April 19, 2019"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
     collapsed: false
     smooth_scroll: false
    df_print: paged
---
##

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Set up environment
This loads libraries, sets working directory, and creates local time zone offset.


```{r Libraries,echo=FALSE,results="hide",warning=FALSE,collapse=TRUE}

library(tidyverse)
library(dplyr)
library(maptools) # to calculate solarpos
library(stringr)
library(lubridate)
library(adehabitatLT)
library(geosphere)
library(ggpubr)
library(sp)
library(rgdal)
library(tibble)
library("rnaturalearth")
library("rnaturalearthdata")
library("sf")
library("ggspatial")
library(marmap)
library(mapdata)
library(metR)
library(RcppRoll)
library(plotrix)
library(ggplot2)
library(ggmap)
library(maps)

# setwd("~/Projects/R/TWlogger")
tzOffset <-"Etc/GMT+3"
```

### Prep Data
This imports and combines data frames to produce data_states.Rdata. Only need to run this section once, unless needing to recreate data_states.Rdata.


##### Import Part 1: HMM states
This imports data with HMM states and runs SunriseSunsetTimes.r.

```{r DataImport,warning=FALSE,results="hide",message=FALSE}
# Load R workspace
load("data_with_states.RData")
# Combine list into one dataframe
data <-bind_rows(data_with_states)
rm(data_with_states)
# Create Spatial Points
data$long <- -60.09
data$lat <- -51.37

# Check dttz 
attr(data$dttz, "tzone") #Check tz
attr(data$dttz, "tzone") <- tzOffset

data$date <- as.Date(data$dttz, tz = tzOffset)

# Run the sunrise sunset script
source('SunriseSunsetTimes.r')
# Check for NAs
sapply(data, function(x) sum(is.na(x)))
# Determine Season (calculated from 2018 solstices and equinoxes)
data$yday <- yday(data$dttz)
data$season <- rep('NA')
#data[which(data$yday > 79 & data$yday <= 173),]$season <- 'Fall'
data[which(data$yday > 173 & data$yday <= 265),]$season <- 'Winter'
#data[which(data$yday > 265 & data$yday < 355),]$season <- 'Spring'
data[which(data$yday >= 355 | data$yday <= 79),]$season <- 'Summer'
data$season <- as.factor(data$season)
unique(data$season)

# Pick up here
# Rename data
data_states <-data
rm(data)

```

##### Import Part 2: Import Raw Acc, combine with HMM states, calculate ODBA
This creates one file that includes states and raw acc. Saves as data_states.Rdata.


```{r Combine,warning=FALSE,results="hide",message=FALSE}
# load Final Metrics from AnalyzeFinalAccV1
load("~/Projects/R/TWlogger/FinalMetrics.RData")
# Add acc data to stateData
data_states <- left_join(data_states,dplyr::select(data,ID,dttz,Ax,Ay,Az), by = c("ID","dttz"))
rm(data)
# Consolidate astronomical periods two periods (day and night)
data_states <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup
# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

# Create SolarMidnight based hourly bins
data_states$solarMidnight <- hms::as.hms((data_states$solarnoon- dhours(12)),tz = tzOffset)
data_states$time <- hms::as.hms(data_states$dttz,tz = tzOffset)
data_states$timeBin <- floor(as.numeric(difftime(data_states$time, data_states$solarMidnight,units = "hours")))
data_states$timeBin <- ifelse(data_states$timeBin < 0,data_states$timeBin+24,data_states$timeBin)
data_states$hr <- hour(data_states$dttz)
data_states$night <- NULL

# Recalculate ODBA (ms-2)
# Calculate static (running mean)
windowSize=11 
data_states <- data_states %>% 
  arrange(ID,dttz) %>% 
  group_by(ID) %>% 
  mutate(static_Ax=roll_mean(Ax,windowSize,fill=NA),
         static_Ay=roll_mean(Ay,windowSize,fill=NA),
         static_Az=roll_mean(Az,windowSize,fill=NA)) %>%
  ungroup

# Replace the NA's at the beginning with the first good value
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>%
  mutate(naUp = ifelse(row_number()<=(windowSize-1)/2+1,1,0),
         naDown = ifelse(row_number() > n() - ((windowSize-1)/2+1),1,0)) %>%# View
  ungroup %>% 
  group_by(ID,naUp) %>% 
  mutate(static_Ax = ifelse(naUp == 1,last(static_Ax),static_Ax),
         static_Ay = ifelse(naUp == 1,last(static_Ay),static_Ay),
         static_Az = ifelse(naUp == 1,last(static_Az),static_Az)) %>% 
  ungroup %>% 
  group_by(ID,naDown) %>% 
  mutate(static_Ax = ifelse(naDown == 1,first(static_Ax),static_Ax),
         static_Ay = ifelse(naDown == 1,first(static_Ay),static_Ay),
         static_Az = ifelse(naDown == 1,first(static_Az),static_Az)) %>% 
  ungroup
data_states$naUp <- NULL
data_states$naDown <- NULL

# Calculate dynamic (raw-static) and ODBA (sum abs dynamic)
data_states <- data_states %>%
  arrange(ID,dttz) %>%
  group_by(ID) %>% 
  mutate(dyn_Ax=Ax-static_Ax,
         dyn_Ay=Ay-static_Ay,
         dyn_Az=Az-static_Az,
         ODBA=abs(dyn_Ax+dyn_Ay+dyn_Az)) %>% 
  ungroup #%>% View

data_states$ODBA <- data_states$ODBA
data_states$state <-ifelse(data_states$state_classif==1|data_states$state_classif==2,"Rest","Active")
data_states$yr <- year(data_states$dttz)
data_states$dawnT <- hour(data_states$dawn) + second(data_states$dawn)/60
data_states$duskT <- hour(data_states$dusk) + second(data_states$dusk)/60


# Check for NAs
sapply(data_states, function(x) sum(is.na(x)))

save(data_states,file="data_states.RData")
```

### Analyze Data
Begin here to continue analysis below. This loads data_states.Rdata which contains ODBA values and state class identified by 4-state HMM.


```{r Load, echo=FALSE,warnings=FALSE}
load("data_states.RData")

```



#### Calculate 4-state counts and proportions by astronomical period
This creates stateSummaryIND. First level analysis. Will group by day (dawn to dusk) and night (dusk to dawn) below.


```{r stateSummaryIND, warnings=FALSE}
# Calculate state count and proportions by 4 periods (dawn, day, dusk, night)
stateSummaryIND <- data_states %>% 
  group_by(season, ID, astronomical) %>% 
  mutate(periodLength = n()) %>% 
  ungroup %>% 
  group_by(season, ID, astronomical, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateProp = stateCount/periodLength) %>% 
  ungroup

# Change classes for plotting
stateSummaryIND$ID <- as.factor(stateSummaryIND$ID)
stateSummaryIND$astronomical <- as.factor(stateSummaryIND$astronomical)

# Create vectors to retain groupings for plots
stateSummaryIND$season_per_state <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,
                                          stateSummaryIND$state_classif,sep="_")
stateSummaryIND$season_period <- paste(stateSummaryIND$season,
                                          stateSummaryIND$astronomical,sep="_")

```

#### Calculate 4-state and 2-state counts and proportions by day and night
This creates stateSummaryIND2period, stateSummaryIND2period2state, dayActive, and dayRest.  

I use HMM state classifications to parse the meaning of my ODBA results. My first question was whether there was a difference in active versus resting states. However, pooling the states into these two categories (i.e. states 1 & 2 are "rest," while 3 & 4 are "active") masks the seasonal difference. When states 3 and 4 are tested individually, there is a seasonal difference in state 4. In winter, caracaras spend more time in state 4. 

It's a question of intensity--rather than duration--of activity.

```{r stateSummaryIND2period, warning=FALSE}
# 4-state, 2 period
# Create new dataframe that combines astronomical periods into day and night and calculates 4-state counts and proportions
stateSummaryIND2period <- data_states %>% 
  group_by(season, ID) %>% 
  mutate(dayNight = ifelse(astronomical %in% c("dawn","day","dusk"),"day","night")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight) %>% 
  mutate(periodLength = n()) %>%
  ungroup %>% 
  group_by(season, ID, dayNight, state_classif,periodLength) %>% 
  summarize(stateCount = n()) %>% 
  mutate(stateCountMin = stateCount/60,
         stateCountHour = stateCount/60/60,
         stateProp = stateCount/periodLength) %>% 
  ungroup

# Create vectors to retain groupings for plots
stateSummaryIND2period$ID <- as.factor(stateSummaryIND2period$ID)
stateSummaryIND2period$dayNight <- as.factor(stateSummaryIND2period$dayNight)
stateSummaryIND2period$season_per_state <- paste(stateSummaryIND2period$season,
                                          stateSummaryIND2period$dayNight,
                                          stateSummaryIND2period$state_classif,sep="_")
stateSummaryIND2period$season_period <- paste(stateSummaryIND2period$season,
                                       stateSummaryIND2period$dayNight,sep="_")
stateSummaryIND2period$state_classif <- as.factor(stateSummaryIND2period$state_classif)

# 2-state, 2 period
# Create new dataframe that combines active and rest states and calculates 2-state count and proportions
stateSummaryIND2period2state <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif) %>%
  mutate(state = ifelse(state_classif %in% c("1","2"),"rest","active")) %>%
  ungroup %>% 
  group_by(season, ID, dayNight,state,periodLength) %>% 
  summarize(stateCount2state = sum(stateCount)) %>% 
  mutate(stateCountMin = stateCount2state/60,
         stateCountHour = stateCount2state/60/60,
         stateProp = stateCount2state/periodLength) %>% 
  ungroup

# Create dataframe of only daytime active state
dayActive <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="active") 

# Create dataframe of only daytime resting state
dayRest <- stateSummaryIND2period2state %>% 
  group_by(season,ID,dayNight,state) %>%
  filter(dayNight=="day",
         state=="rest")

```

#### Justify nighttime exclusion from analysis.

These data suggest a diel pattern between seasons with over 95% of nighttime during both seasons spent in the resting state. This implies that the difference in overall ODBA totals in a 24-hr period are being represented in the daytime. 


```{r restPropSU, warning=FALSE}
# Calculate proportion of time spent resting during night per season
restPropSU <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight,state) %>% 
  summarize(stateProp = mean(stateProp))
restPropSU

# Calculate mean duration of nighttime per season
nightDur <- stateSummaryIND2period2state %>% #View
  group_by(season,dayNight,ID) %>% 
  filter(dayNight == "night") %>%
  summarize(nightDur = sum(stateCountHour))
mNightDur <- nightDur %>% 
  group_by(season) %>% 
  summarize(mNightDurSU = mean(nightDur[season=="Summer"]),
            mNightDurWI = mean(nightDur[season=="Winter"])) %>% View
  
rm(restPropSU,nightDur,mNightDur)

```


```{r PnightDur, warning=FALSE}
# Plot nighttime absolute state durations
PnightDur <- stateSummaryIND2period2state %>% #View
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>%
  ggplot() +
  geom_boxplot(aes(x = state, y = stateCountHour,color = season)) +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 24, by = 2)) +
  labs(x="State",
       y = "Duration (hr)",
       title = "Seasonal nighttime state absolute durations") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Plot nighttime state proportions
PnightProp <- stateSummaryIND2period2state %>% 
  group_by(season,dayNight) %>% 
  filter(dayNight == "night") %>% 
  ggplot() +
  geom_boxplot(aes(x = state, y = stateProp, color = season)) +
  ylim(0,1) +
  labs(x="State",
       y = "Proportion (%)",
       title = "Seasonal nighttime state proportions") + 
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))

# Stack plots to compare full cycle
PnightDurProp <- ggarrange(PnightDur,PnightProp,nrow=2)
PnightDurProp
rm(PnightDur,PnightProp,PnightDurProp)

# Save a file at 300 ppi
# ggsave(PnightDurProp, file="Seasonal nighttime state absolute durations and proportions.png",width=8, height=8, dpi=300)

```

###Q1: Is there a seasonal difference in 24-hr ODBA?

#### Calculate total 24-hr ODBA (g) per individual
This creates sumODBA which contains total daily ODBA (expressed as gravitational force-g) for all individuals across years. This also creates dataframes by season (sumODBASU and sumODBAWI).

```{r sumODBA, warning=FALSE}

# Calculate daily ODBA (g) totals per ID
sumODBA <- data_states %>% 
  group_by(yr,season,ID) %>%
  summarize(sumODBA = sum(ODBA/9.81,na.rm = TRUE)) # convert ODBA from ms-2 to g (divide by 9.81)

# Create dataframes of seasonal daily ODBA (g) totals
sumODBASU <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Summer") 

sumODBAWI <- sumODBA %>% 
  group_by(ID,season,yr) %>%
  filter(season == "Winter") 


```


#### Confirm pooling seasons across years
This tests for differences in total ODBA per year. If there is no interannual difference by seasons, this by default confirms there are no effects from tag versioning. There is no difference in total ODBA per season between years (summer p=0.83, winter p=0.11). Based on zero-normalized density distributions and the shapiro test for normality, I used t-tests to confirm pooling seasons among years.

```{r pool, warning=FALSE}
# Plot density distributions
dSU <- density(sumODBASU$sumODBA-mean(sumODBASU$sumODBA))
plot(dSU)
dWI <- density(sumODBAWI$sumODBA-mean(sumODBAWI$sumODBA))
plot(dWI)

# Test for normality
shapiro.test(sumODBASU$sumODBA)
shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ yr,data=sumODBASU) #Variance is equal
var.test(sumODBA ~ yr,data=sumODBAWI) #Variance is equal

# Test for differences within each season by year to confirm pooling
t.test(sumODBA ~ yr, data=sumODBASU,var.equal = TRUE)
t.test(sumODBA ~ yr, data=sumODBAWI,var.equal = TRUE)

rm(dSU,dWI)

```



#### Test for seasonal differences in total daily ODBA (g)
Daily ODBA values are higher during winter than in summer (winter 2848.07 ± 577.26 g (mean ± SD), summer 2380.85 ± 435.65 g, p-value = 0.03567).



```{r ttestODBAdiff, warning=FALSE}
# Test for normality
shapiro.test(sumODBA$sumODBA) #Results: p-value = 0.7543
# shapiro.test(sumODBASU$sumODBA)
# shapiro.test(sumODBAWI$sumODBA)

# Test for equal variances
var.test(sumODBA ~ season,data=sumODBA) #Variance is equal. Results: p-value = 0.3646

# Test for seasonal differences
test <- t.test(sumODBA ~ season,data=sumODBA,var.equal = TRUE)
test

sd(sumODBASU$sumODBA)
sd(sumODBAWI$sumODBA)

```

#### Alternative test for seasonal differences
This uses a general lineral model to test for year effects on seasonal differences. There were no effects, so I removed year from the model. It's a more elegant analysis than using a t-test to validate seasonal pooling and another t-test for seasonal differences.



```{r glmODBAdiff}
m1 <- glm(sumODBA~season + (1|yr),data=sumODBA, family=)
summary(m1) # m1 gives NAs because don't have all seasons for all years
m2 <- glm(sumODBA~yr*season, data=sumODBA)
summary(m2)
m3 <- glm(sumODBA~season, data=sumODBA)
summary(m3)
rm(m1,m2,m3)
# Results: No effect of year, so can run just by season. Additive model. Removed insignificant variables (e.g. year).

```



#### Figure: Seasonal differences in 24-hr ODBA (g) totals by solar hour

```{r ODBAplot, warning=FALSE}
# Meanline summer
meanlineSU <- data_states %>%
  filter(season == "Summer") %>%
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))
# Meanline winter
meanlineWI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(timeBin) %>% 
  summarize(meanODBA = mean(odbaGSum))

# Calculate time of mean dawn and dusk and create dataframes to use for shading bins in total daily ODBA plot
shadeSU = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Summer"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Summer"])),23),
                     y1=c(0,0),
                     y2=c(800,800))
shadeWI = data.frame(x1=c(0,mean(unique(data_states$duskT[data_states$season == "Winter"]))),
                     x2=c(mean(unique(data_states$dawnT[data_states$season == "Winter"])),23),
                     y1=c(0,0),
                     y2=c(800,800))

# Summer total ODBA per solar hour

PodbaSum24SU <- data_states %>%
  filter(season == "Summer") %>% #View
  group_by(ID, timeBin,dayNight) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7) +
  geom_line(data=meanlineSU,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  scale_y_continuous(breaks = seq(0,800, by = 200), expand = c(0, 0)) +
  scale_x_continuous(breaks = seq(0,23, by = 1),expand = c(0, 0)) +
  labs(x="Solar Hour",
       y = NULL) + 
  geom_rect(data=shadeSU, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  annotate("text", x = 0.75, y = 740, label = "b", color="white") +
  theme_classic(base_size = 13)
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))
PodbaSum24SU

# Winter total ODBA per solar hour
PodbaSum24WI <- data_states %>%
  filter(season == "Winter") %>% #View
  group_by(ID, timeBin) %>%
  summarize(odbaGSum = sum(ODBA/9.81,na.rm = TRUE)) %>% 
  ggplot() +
  geom_line(aes(x=timeBin, y=odbaGSum, group=ID),alpha=0.7)+
  geom_line(data=meanlineWI,aes(x=timeBin, y=meanODBA),color="black",size=1.5) +
  scale_y_continuous(breaks = seq(0,800, by = 200), expand = c(0, 0)) +
  scale_x_continuous(breaks = seq(0,23, by = 1),expand = c(0, 0)) +
  labs(x=NULL,
       y = NULL) + 
  geom_rect(data=shadeWI, mapping=aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), color='grey', alpha=0.5) +
  annotate("text", x = 0.75, y = 740, label = "a", color="white") +
  theme_classic(base_size = 13)
  # theme(plot.title = element_text(size=14)) +
  # theme(axis.text = element_text(size = 14, color = "black"),
  #       axis.title.x = element_text(color="black", size=14),
  #       axis.title.y = element_text(color="black", size=14))
PodbaSum24WI

Podba24Seas <- ggarrange(PodbaSum24WI,PodbaSum24SU,nrow=2)
Podba24Seas <- annotate_figure(Podba24Seas,
               # top = text_grob("Seasonal total ODBA by solar hour", color = "black", size = 14, just="right"),
               left = text_grob("24-h ODBA (g)", color = "black", rot = 90))

Podba24Seas
rm(meanlineSU,meanlineWI,PodbaSum24SU,PodbaSum24WI)
# Save a file at 300 ppi
ggsave(Podba24Seas, file="Seasonal total ODBA per solar hour_shaded.png",dpi=300)
```

#### Calculate daytime hourly ODBA (g) rate and test for seasonal differences
Hourly ODBA values are nearly 2 times higher during winter than in summer (winter 239.50 ± 51.61 g (mean ± SD), summer 127.92 ± 26.01 g, p<0.001).


```{r ttestODBAdiff,warning=FALSE}
# Calculate daytime hourly ODBA rate 
odbaRated <- data_states %>%
  filter(dayNight == "day") %>% 
  group_by(season,ID) %>%
  summarize(odbaGsum = sum(ODBA/9.81,na.rm = TRUE),
            dayLengthHr = n()/60/60) %>% 
  mutate(odbaGrate = odbaGsum/dayLengthHr)

# Test for normality
shapiro.test(odbaRated$odbaGrate) #Results: p-value = 0.2224 

# Test for equal variances
var.test(odbaGrate ~ season,data=odbaRated) #Results: Variance is unequal p=0.03201

# Test for seasonal differences
test <- t.test(odbaGrate ~ season,data=odbaRated,var.equal = FALSE)
test

sd(odbaRated$odbaGrate[odbaRated$season=="Summer"])
sd(odbaRated$odbaGrate[odbaRated$season=="Winter"])
```


#### Figure: Plot daytime hourly ODBA rate by season

```{r}
pd <- position_dodge(0.1) # move them .05 to the left and right
PodbaRated <- odbaRated %>%
  group_by(season) %>% 
  summarize(mRate=mean(odbaGrate),
            seRate=std.error(odbaGrate)) %>%
  ggplot() +
  # geom_boxplot(aes(x=season, y=odbaGrate,color=season)) +
  geom_errorbar(aes(x=season,ymin=mRate-seRate, ymax=mRate+seRate), width=.1,position=pd) +
  geom_point(aes(x=season,y=mRate,colour=season),position=pd,size=3) +
  labs(x= "Season",
       y = "Hourly ODBA (g)",
       title = "Daytime Hourly ODBA by Season") + 
  theme_classic(base_size = 13) + 
  theme(legend.position = "none") +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PodbaRated

ggsave(PodbaRated, file="Hourly ODBA by season.png",dpi=300)

```

### Q2: Confirm no difference in Amag diff between 2017 and 2018/2019

```{r}
#First calculate diff between subsequent values Amag_rollmean_2
diff <- data_states %>% 
  group_by(ID) %>%
  arrange(dttz) %>% 
  mutate(diff = ifelse(row_number()==1,NA,diff(Amag_rollmean_2)),
         ver = ifelse(yr=="2017","V1","V2"))


diff17 <- data_states %>% 
  group_by(ID) %>%
  filter(yr=="2017") %>% 
  arrange(dttz) %>% 
  mutate(diff = ifelse(row_number()==1,NA,diff(Amag_rollmean_2)))

diff1819 <- data_states %>% 
  group_by(ID) %>%
  filter(yr %in% c(2018,2019)) %>% 
  arrange(dttz) %>% 
  mutate(diff = ifelse(row_number()==1,NA,diff(Amag_rollmean_2)))

ggdensity(diff$diff) 
var.test(diff ~ ver, data=diff)
test <- t.test(diff ~ ver, data=diff, var.equal=FALSE)
test
sd(diff$diff[diff$ver=="V1"],na.rm=TRUE)
```


### Q2a: Is there a seasonal difference in daytime activity?

#### Test for seasonal differences in daytime total activity
Pooling the active and resting states masked the seasonal differences in activity. There is no seasonal difference in total time spent in the active state (winter = 5.48 ± 2.18 hr, summer = 5.19 ± 2.38 hr [mean ± SD]; Two Sample t-test, p=0.75).

```{r durdiff, warning=FALSE}
## Test for differences in daytime absolute duration of active state by season

# Test for normality
shapiro.test(dayActive$stateCountHour[dayActive$season=="Summer"]) #Results: p-value = 0.08254
shapiro.test(dayActive$stateCountHour[dayActive$season=="Winter"]) #Results: p-value = 0.1597

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime active state
t.test(stateCountHour ~ season, data = dayActive, var.equal = TRUE) #Results: p-value = 

# Calculate summer mean and standard deviation of daytime absolute duration of active state
dayActiveSUm <- mean(dayActive$stateCountHour[dayActive$season == "Summer"])
dayActiveSUsd <- sd(dayActive$stateCountHour[dayActive$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of active state
dayActiveWIm <- mean(dayActive$stateCountHour[dayActive$season == "Winter"])
dayActiveWIsd <- sd(dayActive$stateCountHour[dayActive$season == "Winter"])

## Test for differences in resting state by season

# Test for normality
shapiro.test(dayRest$stateCountHour[dayRest$season=="Summer"]) #Results: p-value = 0.2386
shapiro.test(dayRest$stateCountHour[dayRest$season=="Winter"]) #Results: p-value =  0.1386

# Test for equal variance
var.test(stateCountHour ~ season, data = dayActive)

# Test for seasonal differences in daytime resting state
t.test(stateCountHour ~ season, data = dayRest, var.equal = TRUE) #Results: p-value = 3.61e-07

# Calculate summer mean and standard deviation of daytime absolute duration of resting state
dayRestSUm <- mean(dayRest$stateCountHour[dayRest$season == "Summer"])
dayRestSUsd <- sd(dayRest$stateCountHour[dayRest$season == "Summer"])

# Calculate winter mean and standard deviation of daytime absolute duration of resting state
dayRestWIm <- mean(dayRest$stateCountHour[dayRest$season == "Winter"])
dayRestWIsd <- sd(dayRest$stateCountHour[dayRest$season == "Winter"])
```

#### ALTERNATIVE more elegant test for seasonal differences in activity levels
KJH: WORK ON THIS. Goal is to test for differences across states between seasons without using individual t-tests. Important because the states are interralated.

```{r}
# KJH: Run this analysis
# 2 way anova with state and season

stateAOV <- aov(stateCountHour ~ season + season, data = stateSummaryIND2period)
summary(stateAOV)
TukeyHSD(stateAOV, which = "state_classif")
stateAOV2 <- aov(boutLengthSec ~ state_classif * season, data = stateBoutSummary)
summary(stateAOV2)
TukeyHSD(stateAOV2, which = "state_classif")
```


### Q2b: Is there a seasonal difference in daytime degree of intensity of activity?

#### Test for seasonal differences in daytime level of activity
This runs one t-test each for seasonal differences in states 3 and 4.  

When the active state is analyzed by degree (i.e. low activity and high activity), these data suggest caracaras spend more time in high activity during winter than in summer (summer 44.1 ± 26.1 min, winter 99.0 ± 45.2 min [mean ± SD]; Two Sample t-test p<0.01). There is no seasonal difference in daily time spent in low activity (summer 267 ± 2.0 min, winter 230 ± 1.6 min (mean ± SD); Two Sample t-test p=0.42). n=12 per season.


```{r lowDurdiff, warning=FALSE}

# Daytime rest

# Test for normality
shapiro.test(dayRest$stateCountMin) #Results: p-value = 0.1202
# Test for equal variance
var.test(stateCountMin ~ season, data = dayRest) #Results: p-value = 0.823
# Test for seasonal differences in daytime rest
t.test(stateCountMin ~ season, data = dayRest, var.equal = TRUE) #Results: t = 7.1506, df = 22, p-value = 3.61e-07

# Calculate summer mean and standard deviation of daytime absolute duration of rest
mean(dayRest$stateCountMin[dayRest$season == "Summer"])
sd(dayRest$stateCountMin[dayRest$season == "Winter"])

# Daytime active

# Test for normality
shapiro.test(dayActive$stateCountMin) #Results: p-value = 0.02133
# Test for equal variance
var.test(stateCountMin ~ season, data = dayActive) #Results: p-value = 0.7784
# Test for seasonal differences in daytime state 1 (rest)
wilcox.test(stateCountMin ~ season, data = dayActive, var.equal = TRUE) # nonparametric alternative to t-tets
t.test(stateCountMin ~ season, data = dayActive, var.equal = TRUE) #Results: t = -0.31845, df = 22, p-value = 0.7531

# Calculate summer mean and standard deviation of daytime absolute duration of state 1 (rest)
mActive <- mean(dayActive$stateCountMin[dayActive$season == "Winter"])/60
sdActive <- sd(dayActive$stateCountMin[dayActive$season == "Summer"])/60
mActive
sdActive

# Daytime state 1 (rest)

# Create dataframe that includes only daytime total duration of state 1 per individual
state1day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="1") %>%
  ungroup

# Test for normality
shapiro.test(state1day$stateCountMin) #Results: p-value = 0.1023
# Test for equal variance
var.test(stateCountMin ~ season, data = state1day) #Results: p-value = 0.387
# Test for seasonal differences in daytime state 1 (rest)
t.test(stateCountMin ~ season, data = state1day, var.equal = TRUE) #Results: t = 3.2504, df = 22, p-value = 0.003669

# Calculate summer mean and standard deviation of daytime absolute duration of state 1 (rest)
mean(state1day$stateCountMin[state1day$season == "Summer"])
sd(state1day$stateCountMin[state1day$season == "Winter"])


# Daytime state 2 (rest with noise)

# Create dataframe that includes only daytime total duration of state 2 per individual
state2day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="2") %>%
  ungroup

# Test for normality
shapiro.test(state2day$stateCountMin) #Results: p-value = 0.1269
# Test for equal variance
var.test(stateCountMin ~ season, data = state2day) #Results: p-value = 0.08113
# Test for seasonal differences in daytime state 2 (rest with noise)
t.test(stateCountMin ~ season, data = state2day, var.equal = TRUE) #Results: t = 5.3585, df = 22, p-value = 2.222e-05

# Calculate summer mean and standard deviation of daytime absolute duration of state 2 (rest with noise)
mean(state2day$stateCountMin[state2day$season == "Summer"])
sd(state2day$stateCountMin[state2day$season == "Winter"])


# Daytime state 3 (low activity)

# Create dataframe that includes only daytime total duration of state 3 per individual
state3day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="3") %>%
  ungroup

# Test for normality
shapiro.test(state3day$stateCountMin) #Results: p-value = 0.1238
# Test for equal variance
var.test(stateCountMin ~ season, data = state3day) #Results: p-value = 0.4837
# Test for seasonal differences in daytime state 3 (low activity)
t.test(stateCountMin ~ season, data = state3day, var.equal = TRUE) #Results: p-value = 0.4173

# Calculate summer mean and standard deviation of daytime absolute duration of state 3 (low activity)
mean(state3day$stateCountMin[state3day$season == "Summer"])
sd(state3day$stateCountMin[state3day$season == "Summer"])
mean(state3day$stateCountMin[state3day$season == "Winter"])
sd(state3day$stateCountMin[state3day$season == "Winter"])

# Daytime State 4 (high activity)

# Create dataframe that includes only daytime total duration of state 4 per individual
state4day <- stateSummaryIND2period %>% 
  group_by(season,ID,dayNight,state_classif,stateCountMin) %>%
  filter(dayNight=="day",
         state_classif=="4") %>%
  ungroup

# Test for normality
shapiro.test(state4day$stateCountMin) #Results: p-value = 0.05814

# Test for equal variance
var.test(stateCountMin ~ season, data = state4day) #Results: p-value = 0.08242

# Test for seasonal differences in daytime state 4 (high activity)
t.test(stateCountMin ~ season, data = state4day, var.equal = TRUE) #Results: t = -3.6417, df = 22, p-value = 0.001439

# Calculate summer mean and standard deviation of daytime absolute duration of state 4 (high activity)
m4WI <-mean(state4day$stateCountMin[state4day$season == "Winter"])
sd4WI <-sd(state4day$stateCountMin[state4day$season == "Winter"])
m4SU <-mean(state4day$stateCountMin[state4day$season == "Summer"])
sd4SU <-sd(state4day$stateCountMin[state4day$season == "Summer"])

```

#### Figure: Seasonal differences in daytime amount of activity (active vs rest)

```{r}
PdayDur2state <- stateSummaryIND2period2state %>%
  group_by(ID,season,dayNight) %>% 
  filter(dayNight == "day") %>%
  ggplot() +
  geom_boxplot(aes(x=state,y=stateCountHour, color = season)) +
  annotate("text", x = 0.5, y = 16, label = "a", color="black") +
  annotate("text", x = 1, y = 15, label = "*", color="black") +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 16, by = 2)) +
  scale_x_discrete(labels = c("Rest", "Active"),
                   limits = c("rest","active")) +
  labs(y = "Duration (h)") + #,
       #title = "Seasonal daytime amounts of activity and rest") + 
  theme_classic(base_size = 13) + 
  theme(legend.position = "none") +
  theme(plot.title = element_text(size=14)) +
  theme(axis.title.x = element_blank())
        #axis.text.x = element_text(color="black", size=14),
        # axis.title.y = element_text(color="black", size=14))
PdayDur2state
ggsave(PdayDur2state, file="Seasonal daytime amount of activity.png",dpi=300)

```


#### Figure: Seasonal differences in daytime degree of activity using state classifications

```{r}
# Plot daytime absolute state durations
PdayDur4state <- stateSummaryIND2period %>%
  group_by(ID,season,dayNight) %>% 
  filter(dayNight == "day") %>%
  ggplot() +
  geom_boxplot(aes(x=state_classif,y=stateCountHour, color = season)) +
  annotate("text", x = 0.6, y = 14, label = "b", color="black") +
  annotate("text", x = 1, y = 11, label = "*", color="black") +
  annotate("text", x = 2, y = 11, label = "*", color="black") +
  annotate("text", x = 4, y = 4.25, label = "*", color="black") +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 14, by = 2)) +
  # scale_x_discrete(labels = c("Rest", "Rest with Noise", "Low Activity","High Activity")) +
  labs(y = "Duration (h)") + 
  theme_classic(base_size = 13) + 
  theme(legend.position = "none") +
  theme(plot.title = element_text(size=14)) +
  theme(axis.text.x=element_blank(),
        axis.title.x = element_blank())
        #axis.title.x = element_text(color="black", size=14),
        # axis.title.y = element_text(color="black", size=14))
PdayDur4state
# Save a file at 300 ppi
# ggsave(PdayDur, file="Seasonal daytime state absolute durations.png",width=12, height=8, dpi=300)
```


#### Figure: Seasonal differences in daytime degree of activity using ODBA

```{r}
dayODBAstate <- data_states %>% 
  group_by(season,ID,dayNight,state_classif) %>% 
  filter(dayNight == "day") %>% 
  summarize(sumODBAstate=sum(ODBA/9.81),
            lengthState=n()/60/60) %>%
  mutate(rateODBAstateHr=sumODBAstate/lengthState)

dayODBAstate4 <- dayODBAstate %>% 
  filter(state_classif == "4")

# Test for normality
shapiro.test(dayODBAstate4$rateODBAstateHr) #Results: p-value = 0.9774

# Test for equal variance
var.test(rateODBAstateHr ~ season, data = dayODBAstate4) #Results: p-value = 0.9602

# Test for seasonal differences in daytime active state
t.test(rateODBAstateHr ~ season, data = dayODBAstate4, var.equal = TRUE) #Results: t = -4.092, df = 22, p-value = 0.000482
# mean winter = 762.2880 
# mean summer = 591.4383
sd(dayODBAstate4$rateODBAstateHr[dayODBAstate4$season=="Summer"])
sd(dayODBAstate4$rateODBAstateHr[dayODBAstate4$season=="Winter"])

PdayODBAstate <- dayODBAstate %>%   
  ggplot() +
  geom_boxplot(aes(x=as.factor(state_classif),y=rateODBAstateHr, color=season)) +
  annotate("text", x = 0.6, y = 1000, label = "c", color="black") +
  annotate("text", x = 4, y = 950, label = "*", color="black") +
  scale_color_discrete(name = "Season") +
  scale_y_continuous(breaks = seq(0, 1000, by = 200)) +
  scale_x_discrete(labels = c("Rest", "Rest with Noise", "Low Activity","High Activity")) +
  # labs(y = expression(paste("Daytime Activity","  ",h^-1," ", "(g)")), y = "") +
  labs(y = expression(paste("ODBA","  ",h^-1," ", "(g)")), y = "") +
  # labs(x="State",
  #      y = "Daytime Activity (ODBA h^-1 g)") + #,
  #      title = "Daytime hourly cost in ODBA (g) by degree of activity")  +
  theme_classic(base_size = 13) + 
  theme(legend.position = "none") +
  # theme(plot.title = element_text(size=14)) +
  theme(#axis.text.x=element_blank(),
        axis.title.x = element_blank())
        # axis.text = element_text(size = 14, color = "black"),
        # axis.title.x = element_text(color="black", size=14),
        # axis.title.y = element_text(color="black", size=14))
PdayODBAstate



# Save a file at 300 ppi
ggsave(PdayODBAstate, file="Seasonal differences in daytime hourly cost in ODBA (g) by degree of activity.png",width=12, height=8, dpi=300)
```


#### Multi-panel plot (Fig 3a-c) of seasonal daytime activity

```{r}
PactiveDiff <- ggarrange(PdayDur2state,PdayDur4state,PdayODBAstate, align="v", nrow=3)

# Save a file at 300 ppi
ggsave(PactiveDiff, file="Seasonal difference in daytime activity.png",dpi=300)


```

#### Plot of seasonal daytime absolute duration of active state by solar hour
Maybe use this one. This plots rest and active by solar hour. During summer, many resources are available across time. Whereas during winter, resources are spatiotemporally fixed.


```{r stateHr, warning=FALSE}
#KJH: Pick up here. In the middle of calculating mean as index of energy use per state bout. Stopped to plot density distribution of ODBA values by state
stateBout <- data_states %>% 
  group_by(season,ID) %>% 
  arrange(dttz) %>%
  mutate(boutNum = cumsum(replace_na(lag(state_classif) != state_classif, 1))) %>%
  ungroup %>% 
  group_by(season,ID,boutNum) %>% 
  mutate(boutLengthSec = n(), #bout length is in seconds
         boutODBAsum = sum(ODBA/9.81,na.rm = TRUE),
         boutODBAmean = mean(ODBA/9.81,na.rm = TRUE)) %>% #mean gives an index of energy use per state 
  ungroup
stateBout$state_classif <- as.factor(stateBout$state_classif)
stateBout$state <- ifelse(stateBout$state_classif==1|stateBout$state_classif==2,"rest","active")
stateBout$hr <- hour(stateBout$dttz)
stateBout$hr <- as.factor(stateBout$hr)

# Create SolarMidnight based hourly bins
stateBout$solarMidnight <- hms::as.hms((stateBout$solarnoon- dhours(12)),tz = tzOffset)
stateBout$time <- hms::as.hms(stateBout$dttz,tz = tzOffset)
stateBout$timeBin <- floor(as.numeric(difftime(stateBout$time, stateBout$solarMidnight,units = "hours")))
stateBout$timeBin <- ifelse(stateBout$timeBin < 0,stateBout$timeBin+24,stateBout$timeBin)
stateBout$timeBin <- as.factor(stateBout$timeBin)

# Remove unused vectors
stateBout <- subset(stateBout, select = c(ID,dttz,true_since,season,dayNight,timeBin,ODBA,state_classif,state,yr,boutNum,boutLengthSec,boutODBAsum,boutODBAmean) )

# Extract bout length
stateBoutSummary <- stateBout %>%
  group_by(season,ID,boutNum,state_classif,dayNight,timeBin,state) %>%
  summarize(boutLengthSec=first(boutLengthSec),
            boutODBAsum=first(boutODBAsum),
            boutODBAmean=boutODBAsum/boutLengthSec) %>%
  ungroup
stateBoutSummary

# Plot daytime absolute state duration by solar hour
pd <- position_dodge(0.1) # move them .05 to the left and right
PcountdayhrAct <- stateBout %>% 
  group_by(ID,dayNight,timeBin,season,state) %>%
  summarize(stateCount=n()/60) %>% #Calculates duration (minutes)
  filter(dayNight=="day",
         state=="active") %>%
  group_by(season,timeBin) %>% 
  summarize(mDur=mean(stateCount),
            seDur=std.error(stateCount)) %>% 
  ggplot() +
  geom_errorbar(aes(x=timeBin,ymin=mDur-seDur, ymax=mDur+seDur), width=.1,position=pd) +
  geom_point(aes(x=timeBin,y=mDur,colour=season),position=pd,size=3) +
  labs(x="Solar Hour",
       y = "Mean Duration (min)",
       title = "Daytime mean active state duration by solar hour") + 
  # scale_x_discrete(limits=0:23) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PcountdayhrAct

# Save a file at 300 ppi
ggsave(PcountdayhrAct, file="Seasonal mean state durations by solar hour.png",width=12, height=8, dpi=300)
```

#### How does ODBA respond to season across states?
This needs work.

```{r}
s1 <- stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="1"]
s2 <- stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="2"]
s3 <- stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="3"]
s4 <- stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="4"]

dStateODBA <- ggplot() +
  geom_density(aes(s1),alpha=0.25) +
  geom_density(aes(s2),alpha=0.25) +
  geom_density(aes(s3),alpha=0.25) +
  geom_density(aes(s4),alpha=0.25)

dStateODBA2 <- stateBoutSummary %>% 
  group_by(season,ID,dayNight,state_classif) %>% 
  summarize(stateODBAsum=sum(boutODBAsum)) %>%
  ggplot()+
  geom_boxplot(aes(state_classif,stateODBAsum,fill=season))
dStateODBA2

library(ggplot2);library(reshape2)
data<- melt(x)
ggplot(data,aes(x=value, fill=variable)) + geom_density(alpha=0.25)


dState3 <- density(stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="3"])
plot(dState3)
dState4 <- density(stateBoutSummary$boutODBAsum[stateBoutSummary$state_classif=="4"])
plot(dState4)
```

### Q2c: Is there a seasonal difference in daytime ODBA?

```{r sumODBA,warning=FALSE}
# Calculate daytime ODBA (g) totals per ID
sumODBAday <- data_states %>% 
  group_by(yr,season,ID) %>%
  filter(dayNight=="day") %>% 
  summarize(sumODBAday = sum(ODBA/9.81,na.rm = TRUE)) # convert ODBA from ms-2 to g (divide by 9.81)
# Test for normality
shapiro.test(sumODBAday$sumODBAday)
# Test for equal variances
var.test(sumODBAday ~ season,data=sumODBAday) #Variance is equal
# Test for seasonal differences
test <- t.test(sumODBAday ~ season,data=sumODBAday,var.equal = TRUE)
test
sd(sumODBAday$sumODBAday[sumODBAday$season=="Summer"])
sd(sumODBAday$sumODBAday[sumODBAday$season=="Winter"])


# Plot daytime absolute state duration by solar hour
pd <- position_dodge(0.1) # move them .05 to the left and right
PODBAdayhr <- stateBout %>% 
  group_by(ID,dayNight,timeBin,season,state) %>%
  summarize(sumODBA=sum(ODBA)) %>%
  filter(dayNight=="day") %>%
  group_by(season,timeBin) %>% 
  summarize(mODBA=mean(sumODBA),
            seODBA=std.error(sumODBA)) %>% 
  ggplot() +
  geom_errorbar(aes(x=timeBin,ymin=mODBA-seODBA, ymax=mODBA+seODBA), width=.1,position=pd) +
  geom_point(aes(x=timeBin,y=mODBA,colour=season),position=pd,size=3) +
  labs(x="Solar Hour of Day",
       y = "Mean ODBA (g)",
       title = "Daytime mean ODBA by solar hour") + 
  # scale_x_discrete(limits=0:23) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
PODBAdayhr

# Save a file at 300 ppi
ggsave(PODBAdayhr, file="Seasonal mean ODBA by solar hour.png",width=12, height=8, dpi=300)

PdayActiveODBA <- ggarrange(PcountdayhrAct,PODBAdayhr,nrow=2)
PdayActiveODBA

ggsave(PdayActiveODBA, file="Seasonal mean state duration and ODBA by solar hour.png",width=12, height=8, dpi=300)

```

### Q4: How does ODBA correlate with state? Is ODBA a function of state bout length?
This calculates mean ODBA per state per ID. 


```{r}

# m1 <- glm(boutODBAmean ~ state_classif + boutLengthSec,data=stateBoutSummary)
# summary(m1)
# TukeyHSD(m1, which = "state_classif")
t1 <- sqrt(stateBoutSummary$boutODBAmean)
t2 <-1/stateBoutSummary$boutODBAmean
stateODBA <- stateBoutSummary %>% 
  ggplot() +
  geom_point(aes(boutLengthSec/60/60,t1,color=state_classif)) +
  scale_color_discrete(name = "State") +
  labs(x="State bout length (hr)",
       y = "Average ODBA (g) per state bout",
       title = "ODBA as a function of state and bout length") + 
  scale_x_continuous(breaks = seq(0,2, by = 0.2),limits=c(0,1.6),expand = c(0, 0)) +
  scale_y_continuous(breaks = seq(0,1.4, by = 0.2),limits=c(0,1),expand = c(0, 0)) +
  theme_classic(base_size = 13) + 
  theme(plot.title = element_text(size=14)) +
  theme(axis.text = element_text(size = 14, color = "black"),
        axis.title.x = element_text(color="black", size=14),
        axis.title.y = element_text(color="black", size=14))
  
stateODBA
ggsave(stateODBA, file="ODBA as a function of state and bout length_v3.png",width=12, height=8, dpi=300)

```


### Q3: Does daily distance traveled differ seasonally?
Calculate daily distance traveled by season. Step length might capture error because of 2-min duty cycle. Can subsample again so we're not affected by accuracy of location. Once I've calculated daily travel distance, I can compare to results of seasonal activity levels. 


```{r GPSstates, warning=FALSE}
# See Analyze TWLoggerGPS script
load("GPS_states.RData")

# Calculate total daytime distance traveled

distSum <- GPS_states %>% 
  group_by(season,ID) %>%
  summarize(distSum = sum(dist,na.rm = TRUE))

# Test for seasonal difference in total distance traveled
shapiro.test(distSum$distSum) #Results: p-value = 0.05187
var.test(distSum ~ season, data = distSum) #Results: p-value = 0.0754
t.test(distSum ~ season, data = distSum, var.equal = TRUE) #Results: t = -4.0636, df = 10, p-value = 0.002274

# Calculate total distance traveled SD
sd(distSum$distSum[distSum$season=="Summer"])
sd(distSum$distSum[distSum$season=="Winter"])

# Calculate max step length per season
distSU <-GPS_states %>% 
  filter(season=="Summer")
distWI <-GPS_states %>% 
  filter(season=="Winter")
mean(distSU$dist,na.rm = TRUE)
mean(distWI$dist,na.rm = TRUE)
sd(distSU$dist,na.rm = TRUE)
sd(distWI$dist,na.rm = TRUE)

# Validate state classifications using distance traveled by state bout? Or mean distance traveled per 1 Hz by state?
# Calculate mean dist traveled by state
# Calculate mean daytime distance traveled by state
# Test for seasonal difference in daytime distance traveled by state


## Map

mapZoom <- 13 # KJH!! Adjust this to fit all the data (20 is all the way zoomed in)
#plot the extent of this map (NOTE: must adjust zoom parameter)
myMap <-  get_googlemap(center = c(lon = mean(c(min(GPS_states$long), max(GPS_states$long))),  lat = mean(c(min(GPS_states$lat),max(GPS_states$lat)))),
                        zoom = mapZoom, 
                        size = c(640,400),
                        scale = 2,
                        extent="device",
                        maptype="hybrid", #"terrain"
                        style = c(feature = "all", element = "labels", visibility = "off"))

#plot map
ggmap(myMap)+
  geom_point(data=gpsData,aes(x=as.numeric(as.character(Long)),y=as.numeric(as.character(Lat))),alpha = 0.5, color= 'yellow') +
  scale_alpha(guide = 'none') + 
  theme(legend.position="right", 
        plot.title = element_text(hjust = 0.5)) + 
  ggtitle(deploymentName) + coord_fixed(1.3) + 
  labs(
    x = "Longitude",
    y = "Latitude"
  )
#save map output as .png
ggsave(sprintf("%s_Map.png",deploymentName), plot = last_plot(), device = "png",
       scale = 2, width = 7, height = 5, units = "in", dpi = 300, limitsize = F)

  
```

